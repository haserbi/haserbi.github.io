<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Spring on Halog</title>
    <link>https://haservi.github.io/categories/spring/</link>
    <description>Recent content in Spring on Halog</description>
    <image>
      <url>https://haservi.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://haservi.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sat, 15 Jan 2022 17:24:58 +0900</lastBuildDate><atom:link href="https://haservi.github.io/categories/spring/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Mybatis와 JPA에 대하여</title>
      <link>https://haservi.github.io/posts/spring/mybatis-and-jpa/</link>
      <pubDate>Sat, 15 Jan 2022 17:24:58 +0900</pubDate>
      
      <guid>https://haservi.github.io/posts/spring/mybatis-and-jpa/</guid>
      <description>Mybatis란? 자바의 관계형 데이터베이스 프로그래밍을 좀 더 쉽게 할 수 있게 도와 주는 개발 프레임 워크입니다.
JDBC를 통해 데이터베이스에 엑세스하는 작업을 캡슐화하고 일반 SQL 쿼리, 저장 프로시저 및 고급 매핑을 지원하며 모든 JDBC 코드 및 매개 변수의 중복작업을 제거 합니다.
또한 Java코드와 SQL코드를 분리하여 서로 다른 역할에 집중할 수 있게 합니다.
MyBatis는 DAO(Data Access Object)인터페이스를 통해 SQL과 연결 후 VO(Value Object) 또는 DTO(Data Transfer Object)로 바로 데이터를 가져옵니다.
JPA란? JPA(Java Persistence API)는 ORM(Object-Relational Mapping) 기술 표준으로 JPA가 제공하는 API를 사용하면 직접적으로 SQL을 사용하지 않고도 DB에 접근이 가능합니다.</description>
    </item>
    
    <item>
      <title>@Autowired와 @RequiredArgsConstructor 차이점 </title>
      <link>https://haservi.github.io/posts/spring/diff-requiredargsconstructor-autowired/</link>
      <pubDate>Wed, 12 Jan 2022 13:39:01 +0900</pubDate>
      
      <guid>https://haservi.github.io/posts/spring/diff-requiredargsconstructor-autowired/</guid>
      <description>@Autowired는 필드 주입이고, @RequiredArgsConstructor는 생성자 주입(Constructor Injection) 입니다.
@RequiredArgsConstructor는 Lombok에서 제공하는 어노테이션 입니다.
결론적으로 생성자 주입을 권장합니다. 인텔리제이에서 코드를 작성하다보면 @Autowired를 사용하면 아래와 같은 경고를 알려줍니다.
.notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:rgba(217,83,79,.9)}.notice.warning{background:#fae2e2}.notice.info .notice-title{background:#f0b37e}.notice.info{background:#fff2db}.notice.note .notice-title{background:#6ab0de}.notice.note{background:#e7f2fA}.notice.tip .notice-title{background:rgba(92,184,92,.8)}.notice.tip{background:#e6f9e6}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:0.125em;position:relative} Warning
Field injection is not recommended Inspection info: Spring Team recommends: &amp;ldquo;Always use constructor based dependency injection in your beans. Always use assertions for mandatory dependencies&amp;rdquo;.
 뭐.. 추천하지 않고 생성자 주입방식을 쓰라고 하는거 같네요.</description>
    </item>
    
    <item>
      <title>[Spring] Service와 ServiceImpl에 대해</title>
      <link>https://haservi.github.io/posts/spring/service-and-serviceimp/</link>
      <pubDate>Wed, 22 Dec 2021 20:11:56 +0900</pubDate>
      
      <guid>https://haservi.github.io/posts/spring/service-and-serviceimp/</guid>
      <description>Service, ServiceImpl Spring 프로젝트를 하면 종종 관례적으로 Service를 interface로 기능 명세를 한 뒤 ServiceImpl에 기능을 구현하게 되는 Factory Pattern을 사용하게 됩니다.
interface는 기능을 추상화하여 클래스간 결합도를 낮추어 주고, 협업 시 업무분담도 용이합니다.
게임으로 예를 들면 스타크래프트에서 모든 유닛의 기본적인 특성 HP, 이동하기를 interface로 기능만 명시하고 각각 분업하여 유닛에 대한 HP나 이동속도를 구현할 수 있습니다.
하지만 일반적인 Spring 웹프로젝트에서는 Service interface는 1:1 구조인 경우가 많습니다. 만약 확장성을 고려한 1:N의 경우에는 interface로 가는 것이 좋지만 너무 막연한 경우에는 그냥 class로 생성 후 추후 시나리오 변경 또는 로직상 확장성이 필요한 경우 interface로 변경하는 것이 좋다고 생각합니다.</description>
    </item>
    
    <item>
      <title>springtoolsuite4에서 dependency 추가 방법</title>
      <link>https://haservi.github.io/posts/spring/springboot-add-dependency/</link>
      <pubDate>Thu, 02 Dec 2021 16:40:29 +0900</pubDate>
      
      <guid>https://haservi.github.io/posts/spring/springboot-add-dependency/</guid>
      <description>SpringBoot에서 Spring Starter Project로 프로젝트를 처음 만든 후 dependency를 추가하고 싶은 경우 해당 프로젝트 우클릭 후 Spring목록의 Add Starters에서 추가하거나 maven repository링크에서 추가해 줘야 합니다.
maven repository 사이트에서 하나하나 찾아서 넣기 번거로운 경우 쉽게 추가할 수 있습니다.
아마도 인텔리j의 ultimate의 경우에도 위와 비슷한 방법으로 dependency를 추가할 수 있을 것이라 생각되네요.</description>
    </item>
    
    <item>
      <title>JPA ddl-auto 설정과 더미데이터 생성 방법</title>
      <link>https://haservi.github.io/posts/spring/hibernate-ddl-auto/</link>
      <pubDate>Fri, 12 Nov 2021 15:47:31 +0900</pubDate>
      
      <guid>https://haservi.github.io/posts/spring/hibernate-ddl-auto/</guid>
      <description>ddl-auto 란 JPA에서는 기본적으로 Entity에 테이블을 매핑하면 쿼리를 사용하지 않고 값을 가져올 수 있습니다.
설정 옵션으로
jpa: hibernate: ddl-auto: create #create-drop, update, validate, none 각각의 옵션을 봐보면 아래와 같습니다.
 create : SessionFactory 시작시 스키마를 삭제하고 다시 생성 create-drop : SessionFactory 종료 시 스키마를 삭제 update : SessionFactory 연결된 DB와 비교하여 추가된 항목은 추가 만약 같은 변수명이면 오류발생 validate : SessionFactory 시작시 객체구성과 스키마가 다르다면 예외 발생 none: 아무것도 안함  실제 서비스 배포시에는 create, create-drop, update 와 같은 옵션을 사용하면 안되지만 개발 초기 테스트시에는 유용하게 사용할 수 있습니다.</description>
    </item>
    
  </channel>
</rss>
