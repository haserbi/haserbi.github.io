[{"content":"SpringBoot에서 Spring Starter Project로 프로젝트를 처음 만든 후 dependency를 추가하고 싶은 경우 해당 프로젝트 우클릭 후 Spring목록의 Add Starters에서 추가하거나 maven repository링크에서 추가해 줘야 합니다.\n\n별 거 아니지만 maver repository 사이트에서 하나하나 찾아서 넣기 번거로운 경우 쉽게 추가할 수 있습니다.\n아마도 인텔리j의 ultimate의 경우에도 위와 비슷한 방법으로 dependency를 추가할 수 있을 것이라 생각되네요.\n","permalink":"https://haservi.github.io/posts/spring/springboot-add-dependency/","summary":"SpringBoot에서 Spring Starter Project로 프로젝트를 처음 만든 후 dependency를 추가하고 싶은 경우 해당 프로젝트 우클릭 후 Spring목록의 Add Starters에서 추가하거나 maven repository링크에서 추가해 줘야 합니다.\n\n별 거 아니지만 maver repository 사이트에서 하나하나 찾아서 넣기 번거로운 경우 쉽게 추가할 수 있습니다.\n아마도 인텔리j의 ultimate의 경우에도 위와 비슷한 방법으로 dependency를 추가할 수 있을 것이라 생각되네요.","title":"springtoolsuite4에서 dependency 추가 방법"},{"content":"기본적으로 웹상에서는 Git 저장소 안의 폴더를 다운받으려면 해당 저장소 전부를 다운 받은 후에 특정 폴더의 정보를 봐야 합니다.\n간단한 방법은 아래의 링크에서 다운로드 받는게 제일 쉬운방법이지만 터미널에서 다운로드 방법도 한번 다루어보겠습니다. 터미널로 다운 받은 경우 이후 해당 소스가 변경이 있다면 당겨올 수 있는 이점도 있습니다.\n해결방법 웹 다운로드 https://downgit.github.io/#/home 해당 사이트에 github 저장소 특정 폴더의 링크를 복사 한 후 붙여넣고 Download 버튼 클릭\n터미널 다운로드 기본적으로 git이 설치돼 있어야합니다.\n예제로 https://github.com/android/architecture-components-samples/tree/main/NavigationAdvancedSample 해당 저장소를 다운받는다고 가정하겠습니다.\n 폴더 생성 후 이동  mkdir sample-code1 cd sample-code1 git 초기화  git init git checkout 설정 변경  git config core.sparseCheckout true 원하는 git 저장소 추가  git remote add -f origin https://github.com/android/architecture-components-samples.git 원하는 특정 폴더 저장소 선택(window)  echo NavigationAdvancedSample/* \u0026gt; .git/info/sparse-checkout 원하는 특정 폴더 저장소 선택(ubuntu)  echo \u0026#34;NavigationAdvancedSample/*\u0026#34; \u0026gt; .git/info/sparse-checkout git 당기기(특정 브렌치 정보)  git pull origin main 사소한 이슈이지만 Windows에서는 경로를 인용해서는 안된다고 하네요. 그렇기 때문에 \u0026ldquo;\u0026ldquo;을 붙이면 안됩니다(참고)\n","permalink":"https://haservi.github.io/posts/tools/how-to-git-inner-folder-download/","summary":"기본적으로 웹상에서는 Git 저장소 안의 폴더를 다운받으려면 해당 저장소 전부를 다운 받은 후에 특정 폴더의 정보를 봐야 합니다.\n간단한 방법은 아래의 링크에서 다운로드 받는게 제일 쉬운방법이지만 터미널에서 다운로드 방법도 한번 다루어보겠습니다. 터미널로 다운 받은 경우 이후 해당 소스가 변경이 있다면 당겨올 수 있는 이점도 있습니다.\n해결방법 웹 다운로드 https://downgit.github.io/#/home 해당 사이트에 github 저장소 특정 폴더의 링크를 복사 한 후 붙여넣고 Download 버튼 클릭\n터미널 다운로드 기본적으로 git이 설치돼 있어야합니다.\n예제로 https://github.","title":"Github 저장소 안의 폴더 다운로드 받는 방법"},{"content":"들어가며 작업의 효율을 높이기 위해 기존 화면에서 필요한 정보를 잠시 동안 캡쳐하는 방법이 있습니다.\n캡쳐프로그램은 정말 다양하게 존재하는데요. 예를 들어 알캡쳐, picpic, 윈도우 기본 내장 캡쳐, pureRef, snipaste 등 많이 있습니다.\n저 같은 경우 포스팅 할 때 화면캡쳐 용도로는 picpick을 자주 이용하며, 업무 중 필요한 정보를 캡쳐 할 때는 snipaste를 사용합니다.\n(picpick)[https://picpick.app/ko/]의 경우는 워낙 잘 알려져 있기 때문에 snipaste에 대해 알아보겠습니다.\nSnipaste (download link) Snipaste는 특정 화면을 지정하여 캡쳐하여 화면에 띄워놓을 수 있습니다.\nWindows는 지원하고 있으며, Mac의 경우 Beta테스트를 하는 것 같네요.\n기본적인 기능으로는 특정 화면 캡쳐, 캡쳐 화면 Color Picker, 캡쳐 화면 확대 축소, 캡쳐 화면 투명도 조절, 캡쳐 화면 저장, 캡쳐 화면 Annotation 지정 등이 있습니다.\n기본 버전으로도 충분히 이용할 수 있지만, pro버전 도 지원을 하는 것 같습니다.\n설치 방법 해당 사이트에서 다운로드 후 설치하시면 됩니다.\n사용방법 기본적인 사용방법은 설치 후 F1로 화면 선택 또는 영역 지정 후 화면에서 더블 클릭 후 F3을 눌러 출력 하면 됩니다.\n\n단축키를 변경 할 수도 있으며, 위를 이용하면 다양한 용도로 사용 할 수 있을 것이라 생각됩니다.\n제 경우 자주 사용하는 용도로는 변수 참조용 또는 퍼블리싱 디자인 또는 유용한 디자인을 참조할 때 자주 쓰는 것 같습니다.\n이외에도 잘 활용하면 여러모로 쾌적한 이용할 수 있지 않을까요??\n그 중에 제가 자주 사용하는 기능에 대해 말씀드리면\n 화면 캡쳐: F1 후 영역 더블클릭 또는 클릭 후 드레그 하여 화면 지정 후 더블클릭 화면 불러오기: F1 저장 후 F3 캡쳐 화면 이동: F3으로 불러오 화면에서 마우스 좌클릭 후 이동 캡쳐 화면 이동: F3으로 불러오 화면에서 마우스 휠 조정 캡쳐 화면 색상 확인: F3으로 불러온 화면에서 Alt키를 누른 후 원하는 색상에서 C버튼 클릭(복사됨) 캡쳐 화면 투명도 조절: F3으로 불러온 화면에서 Ctrl키를 누른 후 마우스 휠 조정 캡쳐 화면 주석 추가: F3으로 불러온 화면에서 Annotation 선택 후 그림도구 사용  이 정도가 될 것 같습니다.\n","permalink":"https://haservi.github.io/posts/tools/how-to-capture/","summary":"들어가며 작업의 효율을 높이기 위해 기존 화면에서 필요한 정보를 잠시 동안 캡쳐하는 방법이 있습니다.\n캡쳐프로그램은 정말 다양하게 존재하는데요. 예를 들어 알캡쳐, picpic, 윈도우 기본 내장 캡쳐, pureRef, snipaste 등 많이 있습니다.\n저 같은 경우 포스팅 할 때 화면캡쳐 용도로는 picpick을 자주 이용하며, 업무 중 필요한 정보를 캡쳐 할 때는 snipaste를 사용합니다.\n(picpick)[https://picpick.app/ko/]의 경우는 워낙 잘 알려져 있기 때문에 snipaste에 대해 알아보겠습니다.\nSnipaste (download link) Snipaste는 특정 화면을 지정하여 캡쳐하여 화면에 띄워놓을 수 있습니다.","title":"화면 캡쳐 프로그램 추천"},{"content":"Windows WSL Ubuntu 커스텀 하기 Window에서는 WSL(Windows Subsystem for Linux)를 제공합니다.\n예전엔 가상환경(VM)에 리눅스를 올렸다면 지금은 손쉽게 리눅스 커널을 WSL로 접근할 수 있게 됐습니다.\n그렇기 때문에 웹개발을 한다면 Window에서 개발하여 WSL에 배포 테스트를 손쉽게? 할 수 있는 환경을 구축 할 수 있습니다. 예를 들어 웹의 경우 Backend, Frontend, DB 같은 환경을 Docker로 설정하여 WSL에 올린 뒤 바로 배포가 성공했다면 이러한 설정을 그대로 AWS나 Azure에 적용할 수 있습니다.\n해당 글은 단지 커스텀에 대한 이야기이지만 추후 위와 같은 방법으로 배포테스트도 한 번 다뤄볼 생각입니다.\n먼저 이 글대로 설정을 마칠 경우 아래와 같은 터미널을 얻을 수 있습니다. 😮\n\n설치 방법 1. Ubuntu 설치 Window Store에서 Ubuntu를 설치합니다. \n2. zsh 설치  먼저 ubuntu 업데이트를 진행합니다.  sudo apt-get install sudo apt-get update zsh를 기본 셸로 설정합니다.  sudo chsh -s $(which zsh) 실행 시 zsh를 실행되도록 지정합니다.  sh -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026#34; 3. Meslo Nerd Font 설치   해당 폰트를 사용하지 않으면 powerlevel10k 테마의 아이콘이 표시되지 않습니다.\n아래 링크를 통해 MesloLGS NF 폰트를 다운로드 받아주세요.\nromkatv/powerlevel10k \n  다운받은 폰트를 Ubuntu에서 폰트를 변경합니다. 상단에서 마우스 우클릭 후 속성을 누른 뒤 폰트를 변경 할 수 있습니다. \n  4. powerlever10k 설치  zsh를 설치하면 oh-my-zsh라는 폴더가 생깁니다. 해당 폴더에 아래의 테마를 설치합니다.  git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k 설치 후 편집기를 이용하여 테마를 변경합니다.  vim ~/.zshrc 기존 테마인 ZSH_THEME=\u0026ldquo;robbyrussell\u0026quot;를 ZSH_THEME=\u0026ldquo;powerlevel10k/powerlevel10k\u0026rdquo; 로 변경합니다.(i를 누르면 편집이 가능하며, 수정이 완료된 뒤 ESC를 누르고 :wq 입력)  ZSH_THEME=\u0026#34;powerlevel10k/powerlevel10k\u0026#34; \n 적용을 하셨다면 해당 창을 종료 후 다시 시작하면 아래와 같이 나오게 됩니다.\n(만약 나오지 않은 경우 명령어 source ~/.zshrc 입력) \n  여기서 본인의 스타일에 맞게 ()안의 답을 선택하면 됩니다. 만약 설정을 잘못하셨거나 바꾸고 싶다면 아래의 커맨드를 입력하시면 됩니다.\n  p10k configure 5. 폴더 아이콘 테마 변경  해당 테마를 변경하기 위해서는 ruby를 설치하여 colorls를 설치해야 합니다.  sudo apt-get install ruby-full colorls를 설치합니다.(만약 아래의 명령어가 안되거나 우분투 20.04 이상 버전인 경우는 sudo apt install gcc make 커맨드 입력 후 다시 설치하시면 됩니다.)  sudo gem install colorls 설치가 완료됐으면 ~/.zshrc 가장 하단에 아래 코드를 추가합니다.  source $(dirname $(gem which colorls))/tab_complete.sh alias ls=colorls \n6. fzf 설치 fzf는 zsh의 확장팩? 같은 느낌입니다. 일단 속도가 매우 빠릅니다.(golang??)\n터미널에서 파일검색, 명령 기록, 프로세스, 호스트 이름, 책갈피 등 다양한 기능이 있습니다.\n몇가지 자주쓰는 명령어로\n ctrl + r 커맨드에서 사용한 명령어 history 리스트 출력 ctrl + t 해당 폴더의 디렉토리 또는 파일 검색 vim $(fzf) 해당 폴더 안의 검색된 파일 열기 cd 스페이스 ctrl + t 검색 후 폴더 이동  이것 외에도 fzf내에서 플러그인을 설치하여 탐색기처럼 이용할 수도 있고, 프로세스 kill 등 다양한 방법이 있는데 저도 아직 제대로 활용은 못하는 것 같습니다\u0026hellip;\n이와 관련된 링크로 대체하겠습니다. 😓\n윈도우 터미널 테마 변경 WSL를 설치하면 store에 있는 윈도우 터미널도 WSL을 선택할 수 있습니다. 이와 관련하여 테마를 설정할 수 있습니다.\n1. 터미널 색상 변경 기본적으로 터미널의 색을 바꾸고 싶다면  위와 같이 설정에 들어가서 json 파일 선택 후 defaults 제이슨 값에\n\u0026#34;defaults\u0026#34;: { // color theme \u0026#34;colorScheme\u0026#34;: \u0026#34;Campbell\u0026#34; }, 해당 테마이름을 지정하고, profiles제이슨 항목 안에\n\u0026#34;schemes\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Campbell\u0026#34;, \u0026#34;cursorColor\u0026#34;: \u0026#34;#FFFFFF\u0026#34;, \u0026#34;selectionBackground\u0026#34;: \u0026#34;#FFFFFF\u0026#34;, \u0026#34;background\u0026#34;: \u0026#34;#0C0C0C\u0026#34;, \u0026#34;foreground\u0026#34;: \u0026#34;#CCCCCC\u0026#34;, \u0026#34;black\u0026#34;: \u0026#34;#0C0C0C\u0026#34;, \u0026#34;blue\u0026#34;: \u0026#34;#4b6ed6\u0026#34;, \u0026#34;cyan\u0026#34;: \u0026#34;#3A96DD\u0026#34;, \u0026#34;green\u0026#34;: \u0026#34;#C50F1F\u0026#34;, \u0026#34;purple\u0026#34;: \u0026#34;#881798\u0026#34;, \u0026#34;red\u0026#34;: \u0026#34;#C50F1F\u0026#34;, \u0026#34;white\u0026#34;: \u0026#34;#CCCCCC\u0026#34;, \u0026#34;yellow\u0026#34;: \u0026#34;#C19C00\u0026#34;, \u0026#34;brightBlack\u0026#34;: \u0026#34;#767676\u0026#34;, \u0026#34;brightBlue\u0026#34;: \u0026#34;#3B78FF\u0026#34;, \u0026#34;brightCyan\u0026#34;: \u0026#34;#61D6D6\u0026#34;, \u0026#34;brightGreen\u0026#34;: \u0026#34;#16C60C\u0026#34;, \u0026#34;brightPurple\u0026#34;: \u0026#34;#B4009E\u0026#34;, \u0026#34;brightRed\u0026#34;: \u0026#34;#E74856\u0026#34;, \u0026#34;brightWhite\u0026#34;: \u0026#34;#F2F2F2\u0026#34;, \u0026#34;brightYellow\u0026#34;: \u0026#34;#F9F1A5\u0026#34; } ], 이렇게 지정해주면 됩니다. 공식 사이트(링크) 에서도 참조하면 좋을 것 같습니다.\n위와 같은 방법으로 다른 테마를 적용하고 싶다면, https://windowsterminalthemes.dev/ 에서 원하는 테마를 복사하셔도 됩니다.\n2. 터미널 배경 변경 터미널 배경을 변경하고 싶으면 아래와 같이 설정해주시면 됩니다.\n\u0026#34;defaults\u0026#34;: { \u0026#34;acrylicOpacity\u0026#34; : 0.4, \u0026#34;backgroundImage\u0026#34;: \u0026#34;D:/ProgramFiles/Images/cool-wallpaper-preview-1.jpg\u0026#34;, \u0026#34;backgroundImageOpacity\u0026#34;: 0.4 }, 3. 글꼴 변경 해당 글꼴을 넣어줘야 powerlink10k에서 아이콘을 볼 수 있습니다.\n\u0026#34;defaults\u0026#34;: { \u0026#34;fontFace\u0026#34; : \u0026#34;MesloLGS NF\u0026#34;, \u0026#34;fontSize\u0026#34; : 13 }, 탐색기에 WSL 연결하기  탐색기 주소창에 아래의 주소값을 입력합니다.  \\\\wsl$ Unbutu 폴더에서 우측마우스 클릭 후 네트워크 드라이브 연결을 선택한다. 연결 후 원하는 이름으로 변경하면 탐색기에서 WSL에 접근이 가능합니다.   에러 관련  아래와 같은 에러가 발생하면  bash: ll: command not found 이렇게 명령어를 입력하면 해결됩니다.  echo \u0026#34;alias ll=\u0026#39;ls -lGaf\u0026#39;\u0026#34; \u0026gt;\u0026gt; ~/.bash_profile source ~/.bash_profile 이상으로 윈도우에서 WSL 우분투 터미널 꾸미는 방법에 대해 알아보았습니다.\nReference  Setting up Windows Terminal, WSL and Oh-my-Zsh - Ivo\u0026rsquo;s Blog! https://snowdeer.github.io/mac-os/2018/11/04/how-to-use-fzf/ fzf Github WSL 동작 원리 FZF 터미널 사용 방법  ","permalink":"https://haservi.github.io/posts/linux/used-zsh-powerline10/","summary":"Windows WSL Ubuntu 커스텀 하기 Window에서는 WSL(Windows Subsystem for Linux)를 제공합니다.\n예전엔 가상환경(VM)에 리눅스를 올렸다면 지금은 손쉽게 리눅스 커널을 WSL로 접근할 수 있게 됐습니다.\n그렇기 때문에 웹개발을 한다면 Window에서 개발하여 WSL에 배포 테스트를 손쉽게? 할 수 있는 환경을 구축 할 수 있습니다. 예를 들어 웹의 경우 Backend, Frontend, DB 같은 환경을 Docker로 설정하여 WSL에 올린 뒤 바로 배포가 성공했다면 이러한 설정을 그대로 AWS나 Azure에 적용할 수 있습니다.\n해당 글은 단지 커스텀에 대한 이야기이지만 추후 위와 같은 방법으로 배포테스트도 한 번 다뤄볼 생각입니다.","title":"윈도우 WSL2 Ubuntu 터미널 꾸미기"},{"content":"ddl-auto 란 JPA에서는 기본적으로 Entity에 테이블을 매핑하면 쿼리를 사용하지 않고 값을 가져올 수 있습니다.\n설정 옵션으로\njpa: hibernate: ddl-auto: create #create-drop, update, validate, none 각각의 옵션을 봐보면 아래와 같습니다.\n create : SessionFactory 시작시 스키마를 삭제하고 다시 생성 create-drop : SessionFactory 종료 시 스키마를 삭제 update : SessionFactory 연결된 DB와 비교하여 추가된 항목은 추가 만약 같은 변수명이면 오류발생 validate : SessionFactory 시작시 객체구성과 스키마가 다르다면 예외 발생 none: 아무것도 안함  실제 서비스 배포시에는 create, create-drop, update 와 같은 옵션을 사용하면 안되지만 개발 초기 테스트시에는 유용하게 사용할 수 있습니다.\n샘플데이터 추가 방법 그렇지만 데이터 테이블만 생기고 데이터가 없으니 오히려 테스트하기 불편한 점이 있습니다.\n그렇기에 찾아보니 역시 당연하게도.. resources 폴더에 import.sql 파일을 추가하면 hibernate에서 알아서 해당 더미데이터 쿼리를 찾아 실해시켜줍니다.\n만약 특정 파일을 지정하고 싶다면 아래와 같이\njpa: properties: hibernate: hbm2ddl: import_files: classpath:db/data.sql 파일명을 명시주면 create에 자동으로 해당 데이터를 insert 할 수 있습니다.\n예제 만약 아래와 같이 user 테이블이 있다면..\nimport java.time.LocalDateTime; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.Table; import lombok.AccessLevel; import lombok.Builder; import lombok.Getter; import lombok.NoArgsConstructor; import org.hibernate.annotations.ColumnDefault; import org.hibernate.annotations.DynamicUpdate; @NoArgsConstructor(access = AccessLevel.PROTECTED) @Getter @Entity @DynamicUpdate @Table(name = \u0026#34;user\u0026#34;) public class UserEntity { @Id @GeneratedValue(strategy= GenerationType.IDENTITY) @Column(nullable = false, updatable = false) private Long userSno; @Column(length = 20, nullable = false, unique = true) private String userId; @Column(length = 20) private String userName; @Column(length = 20, nullable = false) private String password; @Column(length = 30) private String email; @Column(nullable = false, updatable = false, insertable = false, columnDefinition = \u0026#34;TIMESTAMP DEFAULT CURRENT_TIMESTAMP\u0026#34;) private LocalDateTime createDt; @Column(nullable = false, updatable = false, insertable = false) @ColumnDefault(\u0026#34;0\u0026#34;) private int useYn; @Builder public UserEntity(Long userSno, String userId, String userName, String password, String email) { this.userSno = userSno; this.userId = userId; this.userName = userName; this.password = password; this.email = email; } } import.sql파일 또는 지정한 sql파일에 아래와 같이 코드를 추가해주면 빌드 시 자동적으로 데이터를 넣을 수 있습니다.\ninsertinto`user`(`email`,`password`,`user_id`,`user_name`)values(\u0026#39;admin@admin.com\u0026#39;,\u0026#39;$2a$10$dyiw3YfbmBkHlUdbgWhsYesqniOsXo71KBzF75le5.YtS/rsrsM22\u0026#39;,\u0026#39;admin\u0026#39;,\u0026#39;관리자\u0026#39;);insertinto`user`(`email`,`password`,`user_id`,`user_name`)values(\u0026#39;test@test.com\u0026#39;,\u0026#39;$2a$10$PMc5QFOUViVsGmsNMQqUzOuQG2rZ2wUJjSTRGFkBo9jZR/CSnQ03K\u0026#39;,\u0026#39;test\u0026#39;,\u0026#39;테스트\u0026#39;);주의할 점은 실제 배포시에는 꼭 ddl-auto를 none으로 하여 데이터가 날라가는 불상사가 없어야 할 것 같습니다.\n","permalink":"https://haservi.github.io/posts/spring/jpa/hibernate-ddl-auto/","summary":"ddl-auto 란 JPA에서는 기본적으로 Entity에 테이블을 매핑하면 쿼리를 사용하지 않고 값을 가져올 수 있습니다.\n설정 옵션으로\njpa: hibernate: ddl-auto: create #create-drop, update, validate, none 각각의 옵션을 봐보면 아래와 같습니다.\n create : SessionFactory 시작시 스키마를 삭제하고 다시 생성 create-drop : SessionFactory 종료 시 스키마를 삭제 update : SessionFactory 연결된 DB와 비교하여 추가된 항목은 추가 만약 같은 변수명이면 오류발생 validate : SessionFactory 시작시 객체구성과 스키마가 다르다면 예외 발생 none: 아무것도 안함  실제 서비스 배포시에는 create, create-drop, update 와 같은 옵션을 사용하면 안되지만 개발 초기 테스트시에는 유용하게 사용할 수 있습니다.","title":"JPA ddl-auto 설정과 더미데이터 생성 방법"},{"content":"들어가며 어떠한 물건에 대해 설명할 때 말보다 해당 물건을 보여주면 훨씬 빠른 이해가 될 수 있으며, 어느 정도 큰 흥미도 생기게 됩니다.\n종종 어떤 블로그분들을 보면 gif로 구현 방법을 설명해주는데 처음에는 영상을 찍고, 해당 영상을 웹에서 변환하는 작업을 거치는 줄(물론 이렇게도 가능합니다.) 알았는데 훨씬 간편한 방법이 있어 공유 차원에 글을 적습니다.\n저의 경우 Window 환경에서 작업하기 때문에 Window로 설치하는 방법에 대해 알아보겠습니다.\n맥의 경우 아래 참조 블로그 링크를 이용하시면 해결할 수 있습니다.\n설치 방법(Window)  https://www.screentogif.com/ 사이트에 접속하셔서 다운로드 합니다. 다운로드 후 설치 합니다. 설치가 완료되면 실행합니다.  위와 같은 화면에서 선택 영역을 지정(예시: 메모장)하고 녹화를 누르면 아래와 같이 나타납니다.  여기서 그냥 녹화를 누른뒤 진행하면 됩니다. 녹화를 마치고 정지를 누르시면 아래와 같은 화면이 나타납니다.  저 같은 경우 초당 30프레임으로 설정하여서 5초짜리 영상에 대략 150프레임의 스크린샷이 찍혔습니다. 많약 더 부드럽게 만드시고 싶다면 프레임을 올리면 됩니다. 그리고 각각의 프레임들은 모두 제거가 가능하기 때문에 쓸모없는 동작들의 프레임을 제거 할 수 있습니다. 편집 작업이 끝나고 상단의 파일의 저장 버튼을 누르시면 됩니다.  최종적으로 아래와 같이 애니메이션 화면을 볼 수 있습니다.   정리 해당 프로그램을 이용하여 처음 구동화면이나 미리 결과물을 보여주면 조금 더 좋을 것 같습니다.\nReference  https://coding-kindergarten.tistory.com/80?category=967454 https://coding-kindergarten.tistory.com/81?category=967454  ","permalink":"https://haservi.github.io/posts/tools/how-to-create-gif/","summary":"들어가며 어떠한 물건에 대해 설명할 때 말보다 해당 물건을 보여주면 훨씬 빠른 이해가 될 수 있으며, 어느 정도 큰 흥미도 생기게 됩니다.\n종종 어떤 블로그분들을 보면 gif로 구현 방법을 설명해주는데 처음에는 영상을 찍고, 해당 영상을 웹에서 변환하는 작업을 거치는 줄(물론 이렇게도 가능합니다.) 알았는데 훨씬 간편한 방법이 있어 공유 차원에 글을 적습니다.\n저의 경우 Window 환경에서 작업하기 때문에 Window로 설치하는 방법에 대해 알아보겠습니다.\n맥의 경우 아래 참조 블로그 링크를 이용하시면 해결할 수 있습니다.","title":"Gif로 영상 만드는 방법"},{"content":"조이스틱 문제 설명 조이스틱으로 알파벳 이름을 완성하세요. 맨 처음엔 A로만 이루어져 있습니다.\nex) 완성해야 하는 이름이 세 글자면 AAA, 네 글자면 AAAA\n조이스틱을 각 방향으로 움직이면 아래와 같습니다.\n▲ - 다음 알파벳 ▼ - 이전 알파벳 (A에서 아래쪽으로 이동하면 Z로) ◀ - 커서를 왼쪽으로 이동 (첫 번째 위치에서 왼쪽으로 이동하면 마지막 문자에 커서) ▶ - 커서를 오른쪽으로 이동 예를 들어 아래의 방법으로 \u0026ldquo;JAZ\u0026quot;를 만들 수 있습니다.\n- 첫 번째 위치에서 조이스틱을 위로 9번 조작하여 J를 완성합니다. - 조이스틱을 왼쪽으로 1번 조작하여 커서를 마지막 문자 위치로 이동시킵니다. - 마지막 위치에서 조이스틱을 아래로 1번 조작하여 Z를 완성합니다. 따라서 11번 이동시켜 \u0026quot;JAZ\u0026quot;를 만들 수 있고, 이때가 최소 이동입니다. 만들고자 하는 이름 name이 매개변수로 주어질 때, 이름에 대해 조이스틱 조작 횟수의 최솟값을 return 하도록 solution 함수를 만드세요.\n제한 사항  name은 알파벳 대문자로만 이루어져 있습니다. name의 길이는 1 이상 20 이하입니다.  입출력 예    name return     \u0026ldquo;JEROEN\u0026rdquo; 56   \u0026ldquo;JAN\u0026rdquo; 23    출처 ※ 공지 - 2019년 2월 28일 테스트케이스가 추가되었습니다.\n문제 풀이 리뷰 몇일을 고민한 문제이다. 알파벳 위아래의 최소값은 간단히 구하였지만, 좌우의 최소거리를 찾는 부분에서 생각을 많이하였다.\n기본적으로 모든 알파벳 위치에서의 최소거리를 구하고, 바로앞의 A가 있다면 해당 값을 제외한 뒤에 거리를 정의해야한다.\n또한, 해당 인덱스의 위치에서 정방향과 역방향에서 둘 중의 거리가 짧은 곳을 구한 뒤 바로앞의 A를 제외한 총이동거리를 더하는 부분이 중요하다.\n그렇게 모든 알파벳의 좌우 이동 최소거리 중 가장작은 값을 상하 알파벳 이동값과 더하여 주면된다.\nSource code public int solution(String name) { int answer = 0; int nameLength = name.length(); int changeAlpabatCount = 0; for (int i = 0; i \u0026lt; nameLength; i++) { // 알파벳 변경 시 최소값 선정 후 화살표 위아래 변경 횟수 추가  changeAlpabatCount += Math.min(name.charAt(i) - \u0026#39;A\u0026#39;, \u0026#39;Z\u0026#39; - name.charAt(i) + 1); } // 알파벳의 정방향 최대 이동거리를 최소거리로 지정  int minMove = nameLength - 1; for (int i = 0; i \u0026lt; nameLength; i++) { int next = i + 1; int nextCountA = 0; while (next \u0026lt; nameLength \u0026amp;\u0026amp; name.charAt(next) == \u0026#39;A\u0026#39;) { next++; nextCountA++; } // 0번쨰 인덱스에서 앞의 A를 제외하고 이동한 거리  int moveWithoutA = name.length() - nextCountA - 1; // System.out.println(\u0026#34;movewithA:\u0026#34; + moveWithoutA);  // 처음부터 i번째 까지 왔다가 돌아가는 방식과 뒤에서 출발하여 i번째 까지 오는 방식중 작은 값 선택  int min = Math.min(i, name.length() - next); // 알파벳을 순회하며 작은 값을 선택  minMove = Math.min(minMove, moveWithoutA + min); // System.out.println(i + \u0026#34;번째값의 평균 이동 거리는 \u0026#34; + (moveWithoutA + min) + \u0026#34;이다.\u0026#34;);  } // System.out.println(\u0026#34;총 알파벳 변경 회수는 \u0026#34; + changeAlpabatCount + \u0026#34;이며, 최소이동 거리는 \u0026#34; + minMove + \u0026#34;이다.\u0026#34;);  answer = (changeAlpabatCount + minMove); return answer; } ","permalink":"https://haservi.github.io/posts/algorithms/programmers/level2/03-joystick/","summary":"조이스틱 문제 설명 조이스틱으로 알파벳 이름을 완성하세요. 맨 처음엔 A로만 이루어져 있습니다.\nex) 완성해야 하는 이름이 세 글자면 AAA, 네 글자면 AAAA\n조이스틱을 각 방향으로 움직이면 아래와 같습니다.\n▲ - 다음 알파벳 ▼ - 이전 알파벳 (A에서 아래쪽으로 이동하면 Z로) ◀ - 커서를 왼쪽으로 이동 (첫 번째 위치에서 왼쪽으로 이동하면 마지막 문자에 커서) ▶ - 커서를 오른쪽으로 이동 예를 들어 아래의 방법으로 \u0026ldquo;JAZ\u0026quot;를 만들 수 있습니다.\n- 첫 번째 위치에서 조이스틱을 위로 9번 조작하여 J를 완성합니다.","title":"[프로그래머스]조이스틱"},{"content":"다리를 지나는 트럭 문제 설명 트럭 여러 대가 강을 가로지르는 일차선 다리를 정해진 순으로 건너려 합니다.\n모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 알아내야 합니다.\n다리에는 트럭이 최대 bridge_length대 올라갈 수 있으며, 다리는 weight 이하까지의 무게를 견딜 수 있습니다.\n단, 다리에 완전히 오르지 않은 트럭의 무게는 무시합니다.\n예를 들어, 트럭 2대가 올라갈 수 있고 무게를 10kg까지 견디는 다리가 있습니다. 무게가 [7, 4, 5, 6]kg인 트럭이 순서대로 최단 시간 안에 다리를 건너려면 다음과 같이 건너야 합니다.\n   경과 시간 다리를 지난 트럭 다리를 건너는 트럭 대기 트럭     0 [] [] [7,4,5,6]   1~2 [] [7] [4,5,6]   3 [7] [4] [5,6]   4 [7] [4,5] [6]   5 [7,4] [5] [6]   6~7 [7,4,5] [6] []   8 [7,4,5,6] [] []    따라서, 모든 트럭이 다리를 지나려면 최소 8초가 걸립니다.\nsolution 함수의 매개변수로 다리에 올라갈 수 있는 트럭 수 bridge_length, 다리가 견딜 수 있는 무게 weight, 트럭 별 무게 truck_weights가 주어집니다.\n이때 모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 return 하도록 solution 함수를 완성하세요.\n제한 조건  bridge_length는 1 이상 10,000 이하입니다. weight는 1 이상 10,000 이하입니다. truck_weights의 길이는 1 이상 10,000 이하입니다. 모든 트럭의 무게는 1 이상 weight 이하입니다.  입출력 예    bridge_length weight truck_weights return     2 10 [7,4,5,6] 8   100 100 [10] 101   100 100 [10,10,10,10,10,10,10,10,10,10] 110    ","permalink":"https://haservi.github.io/posts/algorithms/programmers/level2/02-truck-crossing-the-bridge/","summary":"다리를 지나는 트럭 문제 설명 트럭 여러 대가 강을 가로지르는 일차선 다리를 정해진 순으로 건너려 합니다.\n모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 알아내야 합니다.\n다리에는 트럭이 최대 bridge_length대 올라갈 수 있으며, 다리는 weight 이하까지의 무게를 견딜 수 있습니다.\n단, 다리에 완전히 오르지 않은 트럭의 무게는 무시합니다.\n예를 들어, 트럭 2대가 올라갈 수 있고 무게를 10kg까지 견디는 다리가 있습니다. 무게가 [7, 4, 5, 6]kg인 트럭이 순서대로 최단 시간 안에 다리를 건너려면 다음과 같이 건너야 합니다.","title":"[프로그래머스]다리를 지나는 트럭"},{"content":"목표  하루에 하나씩 알고리즘을 풀며 개인 공부를 하면 뭐라도 도움이 되겠지.\n 후기 전체적인 난이도는 기초적인 반복문을 이해하고 있으며, 간단한 자료구조를 알고 있으면 문제를 푸는데 큰 어려움은 없는 것 같습니다. 가끔씩 카카오 관련 코딩테스트가 아무래도 기존 문제보다 난이도가 조금은 더 있었던 것 같았으며, 그 외의 경우 하루에 하나씩 문제를 풀어도 큰 부담이 안됐던 것 같습니다.\nLevel1을 마무리하고 이제 Level2의 문제를 풀고 있는데 조금 난이도가 올라간 느낌입니다.\n아무래도 Level1 보다는 조금 더 시간이 걸리고 뭔가 제 기초가 부족하다는 것을 느끼게 됐습니다. 알고리즘 문제를 풀며, 꾸준히 기본적인 자료구조와 서적을 통해 기초를 더 쌓아야 할 것 같습니다.😒\n","permalink":"https://haservi.github.io/posts/algorithms/programmers/review/clear-level1/","summary":"목표  하루에 하나씩 알고리즘을 풀며 개인 공부를 하면 뭐라도 도움이 되겠지.\n 후기 전체적인 난이도는 기초적인 반복문을 이해하고 있으며, 간단한 자료구조를 알고 있으면 문제를 푸는데 큰 어려움은 없는 것 같습니다. 가끔씩 카카오 관련 코딩테스트가 아무래도 기존 문제보다 난이도가 조금은 더 있었던 것 같았으며, 그 외의 경우 하루에 하나씩 문제를 풀어도 큰 부담이 안됐던 것 같습니다.\nLevel1을 마무리하고 이제 Level2의 문제를 풀고 있는데 조금 난이도가 올라간 느낌입니다.\n아무래도 Level1 보다는 조금 더 시간이 걸리고 뭔가 제 기초가 부족하다는 것을 느끼게 됐습니다.","title":"프로그래머스 Level1 문제풀이 후기"},{"content":"위장 문제 설명 스파이들은 매일 다른 옷을 조합하여 입어 자신을 위장합니다.\n예를 들어 스파이가 가진 옷이 아래와 같고 오늘 스파이가 동그란 안경, 긴 코트, 파란색 티셔츠를 입었다면 다음날은 청바지를 추가로 입거나 동그란 안경 대신 검정 선글라스를 착용하거나 해야 합니다.\n   종류 이름     얼굴 동그란 안경, 검정 선글라스   상의 파란색 티셔츠   하의 청바지   겉옷 긴 코트    스파이가 가진 의상들이 담긴 2차원 배열 clothes가 주어질 때 서로 다른 옷의 조합의 수를 return 하도록 solution 함수를 작성해주세요.\n제한사항  clothes의 각 행은 [의상의 이름, 의상의 종류]로 이루어져 있습니다. 스파이가 가진 의상의 수는 1개 이상 30개 이하입니다. 같은 이름을 가진 의상은 존재하지 않습니다. clothes의 모든 원소는 문자열로 이루어져 있습니다. 모든 문자열의 길이는 1 이상 20 이하인 자연수이고 알파벳 소문자 또는 \u0026lsquo;_\u0026rsquo; 로만 이루어져 있습니다. 스파이는 하루에 최소 한 개의 의상은 입습니다.  입출력 예    clothes return     [[\u0026ldquo;yellowhat\u0026rdquo;, \u0026ldquo;headgear\u0026rdquo;], [\u0026ldquo;bluesunglasses\u0026rdquo;, \u0026ldquo;eyewear\u0026rdquo;], [\u0026ldquo;green_turban\u0026rdquo;, \u0026ldquo;headgear\u0026rdquo;]] 5   [[\u0026ldquo;crowmask\u0026rdquo;, \u0026ldquo;face\u0026rdquo;], [\u0026ldquo;bluesunglasses\u0026rdquo;, \u0026ldquo;face\u0026rdquo;], [\u0026ldquo;smoky_makeup\u0026rdquo;, \u0026ldquo;face\u0026rdquo;]] 3    입출력 예 설명 예제 #1\nheadgear에 해당하는 의상이 yellow_hat, green_turban이고 eyewear에 해당하는 의상이 blue_sunglasses이므로 아래와 같이 5개의 조합이 가능합니다.\n1. yellow_hat 2. blue_sunglasses 3. green_turban 4. yellow_hat + blue_sunglasses 5. green_turban + blue_sunglasses 예제 #2 face에 해당하는 의상이 crow_mask, blue_sunglasses, smoky_makeup이므로 아래와 같이 3개의 조합이 가능합니다.\n1. crow_mask 2. blue_sunglasses 3. smoky_makeup 문제 풀이 문제 풀이 리뷰  확률 문제이다. 예를 들어 정육각형 주사위A 주사위B 2개로 나오는 경우의 수는 6 * 6으로 36개이다. 그렇지만 주사위 객체 1개도 경우의 수로 인정하게 되면 (7 x 7) - 1로 48개 이다. 여기서 -1은 주사위가 없는 경우라고 생각할 수 있다. 해당 문제도 같은 방식으로 이해하면 각 옷들은 주사위이고 옷의 개수는 주사위의 번호 개수이다. 예를 들어 옷의 종류가 3개이며, 각각 2벌씩이면 ((2 + 1) * (2 + 1) * (2 + 1)) - 1 = 26 이다. 해당 문제의 풀이 방법은 어느 정도 알았지만, hashMap의 확장함수로 getOrDefault가 있다는 것을 알게됐다. getOrDefault의 두 번째 매개변수인 defaultValue는 지정된 키로 매핑된 값이 없으면 반환되는 값이다.  Source code Java (Source code) public int solution(String[][] clothes) { int answer = 1; int clothCount = clothes.length; HashMap\u0026lt;String, Integer\u0026gt; hashMap = new HashMap\u0026lt;String, Integer\u0026gt;(); for (int i = 0; i \u0026lt; clothCount; i++) { int clothSum = hashMap.getOrDefault(clothes[i][1], 0) + 1; hashMap.put(clothes[i][1], clothSum); } for (int count : hashMap.values()) { answer = answer * (count + 1); } answer = answer - 1; return answer; } ","permalink":"https://haservi.github.io/posts/algorithms/programmers/level2/01-camouflage/","summary":"위장 문제 설명 스파이들은 매일 다른 옷을 조합하여 입어 자신을 위장합니다.\n예를 들어 스파이가 가진 옷이 아래와 같고 오늘 스파이가 동그란 안경, 긴 코트, 파란색 티셔츠를 입었다면 다음날은 청바지를 추가로 입거나 동그란 안경 대신 검정 선글라스를 착용하거나 해야 합니다.\n   종류 이름     얼굴 동그란 안경, 검정 선글라스   상의 파란색 티셔츠   하의 청바지   겉옷 긴 코트    스파이가 가진 의상들이 담긴 2차원 배열 clothes가 주어질 때 서로 다른 옷의 조합의 수를 return 하도록 solution 함수를 작성해주세요.","title":"[프로그래머스]위장"},{"content":"하샤드 수 문제 설명 양의 정수 x가 하샤드 수이려면 x의 자릿수의 합으로 x가 나누어져야 합니다.\n예를 들어 18의 자릿수 합은 1+8=9이고, 18은 9로 나누어 떨어지므로 18은 하샤드 수입니다.\n자연수 x를 입력받아 x가 하샤드 수인지 아닌지 검사하는 함수, solution을 완성해주세요.\n제한 조건  x는 1 이상, 10000 이하인 정수입니다.  입출력 예    arr return     10 true   12 true   11 false   13 false    입출력 예 설명 입출력 예 #1\n10의 모든 자릿수의 합은 1입니다. 10은 1로 나누어 떨어지므로 10은 하샤드 수입니다.\n입출력 예 #2\n12의 모든 자릿수의 합은 3입니다. 12는 3으로 나누어 떨어지므로 12는 하샤드 수입니다.\n입출력 예 #3\n11의 모든 자릿수의 합은 2입니다. 11은 2로 나누어 떨어지지 않으므로 11는 하샤드 수가 아닙니다.\n입출력 예 #4\n13의 모든 자릿수의 합은 4입니다. 13은 4로 나누어 떨어지지 않으므로 13은 하샤드 수가 아닙니다.\n문제 풀이 리뷰  [Java](https://github.com/haservi/study-algorithm/blob/main/programmers/Level1/lv1_47_%ED%95%98%EC%83%A4%EB%93%9C_%EC%88%98/Solution.java   각 자리수의 합을 구한 뒤 나머지가 0인 경우 true를 반환한다.  나의 풀이(Source code) public boolean solution(int x) { int sum = 0; int num = x; // 자릿수의 합  while (num != 0) { sum += num % 10; num /= 10; } // 나머지가 0이면 하샤드 수라고 판단  if (x % sum == 0) return true; else return false; } ","permalink":"https://haservi.github.io/posts/algorithms/programmers/level1/04-algo-hasshadsu/","summary":"하샤드 수 문제 설명 양의 정수 x가 하샤드 수이려면 x의 자릿수의 합으로 x가 나누어져야 합니다.\n예를 들어 18의 자릿수 합은 1+8=9이고, 18은 9로 나누어 떨어지므로 18은 하샤드 수입니다.\n자연수 x를 입력받아 x가 하샤드 수인지 아닌지 검사하는 함수, solution을 완성해주세요.\n제한 조건  x는 1 이상, 10000 이하인 정수입니다.  입출력 예    arr return     10 true   12 true   11 false   13 false    입출력 예 설명 입출력 예 #1","title":"[프로그래머스]하샤드 수"},{"content":"콜라츠 추측 문제 설명 1937년 Collatz란 사람에 의해 제기된 이 추측은, 주어진 수가 1이 될때까지 다음 작업을 반복하면, 모든 수를 1로 만들 수 있다는 추측입니다. 작업은 다음과 같습니다.\n1-1. 입력된 수가 짝수라면 2로 나눕니다. 1-2. 입력된 수가 홀수라면 3을 곱하고 1을 더합니다. 2. 결과로 나온 수에 같은 작업을 1이 될 때까지 반복합니다. 예를 들어, 입력된 수가 6이라면 6→3→10→5→16→8→4→2→1 이 되어 총 8번 만에 1이 됩니다.\n위 작업을 몇 번이나 반복해야하는지 반환하는 함수, solution을 완성해 주세요.\n단, 작업을 500번을 반복해도 1이 되지 않는다면 –1을 반환해 주세요.\n제한 사항  입력된 수, num은 1 이상 8000000 미만인 정수입니다.  입출력 예    n result     6 8   16 4   626331 -1    입출력 예 설명 입출력 예 #1\n문제의 설명과 같습니다.\n입출력 예 #2\n16 -\u0026gt; 8 -\u0026gt; 4 -\u0026gt; 2 -\u0026gt; 1 이되어 총 4번만에 1이 됩니다.\n입출력 예 #3\n626331은 500번을 시도해도 1이 되지 못하므로 -1을 리턴해야합니다.\n문제 풀이 문제 풀이 리뷰  반복적으로 돌면서 짝수이면 2로 나누고 홀수이면 해당값에 3을 곱한 후 1을 더해준다. 해당 반복이 500회가 되면 -1을 리턴한다.  Java (Source code) public int solution(long num) { int answer = 0; while (num != 1) { if (num % 2 == 0) { num = num / 2; } else { num = (num * 3) + 1; } answer++; if (answer == 500) { return -1; } } return answer; } ","permalink":"https://haservi.github.io/posts/algorithms/programmers/level1/03-algo-colatz-guess/","summary":"콜라츠 추측 문제 설명 1937년 Collatz란 사람에 의해 제기된 이 추측은, 주어진 수가 1이 될때까지 다음 작업을 반복하면, 모든 수를 1로 만들 수 있다는 추측입니다. 작업은 다음과 같습니다.\n1-1. 입력된 수가 짝수라면 2로 나눕니다. 1-2. 입력된 수가 홀수라면 3을 곱하고 1을 더합니다. 2. 결과로 나온 수에 같은 작업을 1이 될 때까지 반복합니다. 예를 들어, 입력된 수가 6이라면 6→3→10→5→16→8→4→2→1 이 되어 총 8번 만에 1이 됩니다.\n위 작업을 몇 번이나 반복해야하는지 반환하는 함수, solution을 완성해 주세요.","title":"[프로그래머스]콜라츠 추측"},{"content":"직업군 추천하기 문제 설명 개발자가 사용하는 언어와 언어 선호도를 입력하면 그에 맞는 직업군을 추천해주는 알고리즘을 개발하려고 합니다.\n아래 표는 5개 직업군 별로 많이 사용하는 5개 언어에 직업군 언어 점수를 부여한 표입니다.\n   점수 SI CONTENTS HARDWARE PORTAL GAME     5 JAVA JAVASCRIPT C JAVA C++   4 JAVASCRIPT JAVA C++ JAVASCRIPT C#   3 SQL PYTHON PYTHON PYTHON JAVASCRIPT   2 PYTHON SQL JAVA KOTLIN C   1 C# C++ JAVASCRIPT PHP JAVA    예를 들면, SQL의 SI 직업군 언어 점수는 3점이지만 CONTENTS 직업군 언어 점수는 2점입니다.\nSQL의 HARDWARE, PORTAL, GAME 직업군 언어 점수는 0점입니다.\n직업군 언어 점수를 정리한 문자열 배열 table, 개발자가 사용하는 언어를 담은 문자열 배열 languages, 언어 선호도를 담은 정수 배열 preference가 매개변수로 주어집니다.\n개발자가 사용하는 언어의 언어 선호도 x 직업군 언어 점수의 총합이 가장 높은 직업군을 return 하도록 solution 함수를 완성해주세요.\n총합이 같은 직업군이 여러 개일 경우, 이름이 사전 순으로 가장 빠른 직업군을 return 해주세요.\n제한사항  table의 길이 = 5  table의 원소는 \u0026ldquo;직업군 5점언어 4점언어 3점언어 2점언어 1점언어\u0026quot;형식의 문자열입니다. 직업군, 5점언어, 4언어, 3점언어, 2점언어, 1점언어는 하나의 공백으로 구분되어 있습니다. table은 모든 테스트케이스에서 동일합니다.   1 ≤ languages의 길이 ≤ 9  languages의 원소는 \u0026ldquo;JAVA\u0026rdquo;, \u0026ldquo;JAVASCRIPT\u0026rdquo;, \u0026ldquo;C\u0026rdquo;, \u0026ldquo;C++\u0026rdquo; ,\u0026ldquo;C#\u0026rdquo; , \u0026ldquo;SQL\u0026rdquo;, \u0026ldquo;PYTHON\u0026rdquo;, \u0026ldquo;KOTLIN\u0026rdquo;, \u0026ldquo;PHP\u0026rdquo; 중 한 개 이상으로 이루어져 있습니다. languages의 원소는 중복되지 않습니다.   preference의 길이 = languages의 길이  1 ≤ preference의 원소 ≤ 10   preference의 i번째 원소는 languages의 i번째 원소의 언어 선호도입니다. return 할 문자열은 \u0026ldquo;SI\u0026rdquo;, \u0026ldquo;CONTENTS\u0026rdquo;, \u0026ldquo;HARDWARE\u0026rdquo;, \u0026ldquo;PORTAL\u0026rdquo;, \u0026ldquo;GAME\u0026rdquo; 중 하나입니다.  입출력 예    table languages preference result     [\u0026ldquo;SI JAVA JAVASCRIPT SQL PYTHON C#\u0026rdquo;, \u0026ldquo;CONTENTS JAVASCRIPT JAVA PYTHON SQL C++\u0026rdquo;, \u0026ldquo;HARDWARE C C++ PYTHON JAVA JAVASCRIPT\u0026rdquo;, \u0026ldquo;PORTAL JAVA JAVASCRIPT PYTHON KOTLIN PHP\u0026rdquo;, \u0026ldquo;GAME C++ C# JAVASCRIPT C JAVA\u0026rdquo;] [\u0026ldquo;PYTHON\u0026rdquo;, \u0026ldquo;C++\u0026rdquo;, \u0026ldquo;SQL\u0026rdquo;] [7, 5, 5] \u0026ldquo;HARDWARE\u0026rdquo;   [\u0026ldquo;SI JAVA JAVASCRIPT SQL PYTHON C#\u0026rdquo;, \u0026ldquo;CONTENTS JAVASCRIPT JAVA PYTHON SQL C++\u0026rdquo;, \u0026ldquo;HARDWARE C C++ PYTHON JAVA JAVASCRIPT\u0026rdquo;, \u0026ldquo;PORTAL JAVA JAVASCRIPT PYTHON KOTLIN PHP\u0026rdquo;, \u0026ldquo;GAME C++ C# JAVASCRIPT C JAVA\u0026rdquo;] [\u0026ldquo;JAVA\u0026rdquo;, \u0026ldquo;JAVASCRIPT\u0026rdquo;] [7, 5] \u0026ldquo;PORTAL\u0026rdquo;    입출력 예 설명 입출력 예 #1\n각 직업군 별로 점수를 계산해보면 아래와 같습니다.\n아래 사진은 개발자 언어 선호도 나타낸 표입니다.     Python C++ SQL     선호도 7 5 5    아래 사진은 개발자가 선호하는 언어의 직업군 언어 점수를 나타낸 표입니다.     SI CONTENTS HARDWARE PORTAL GAME     PYTHON 2 3 3 3 0   c++ 0 1 4 0 5   SQL 3 2 0 0 0   직업군별 점수 식 $72 + 50 + 5*3$ $73 + 51 + 5*2$ $73 + 54 + 5*0$ $73 + 50 + 5*0$ $70 + 55 + 5*0$   점수 총합 29 36 41 21 25    따라서 점수 총합이 41로 가장 높은 \u0026quot;HARDWARE\u0026quot;를 return 해야 합니다.\n입출력 예 #2 각 직업군 별로 점수를 계산해보면 아래와 같습니다.\n아래 사진은 개발자 언어 선호도 나타낸 표입니다.     JAVA JAVASCRIPT     선호도 7 5    아래 사진은 개발자가 선호하는 언어의 직업군 언어 점수를 나타낸 표입니다.     SI CONTENTS HARDWARE PORTAL GAME     JAVA 5 4 2 5 1   JAVASCRIPT 4 5 1 4 3   직업군별 점수 식 $75 + 54$ $74 + 55$ $72 + 51$ $75 + 54$ $71 + 53$   점수 총합 55 53 19 55 22    점수 총합이 55로 가장 높은 직업군은 \u0026ldquo;SI\u0026rdquo; 와 \u0026ldquo;PORTAL\u0026quot;입니다. 따라서 사전 순으로 먼저 오는 \u0026quot;PORTAL\u0026quot;을 return 해야 합니다.\n문제 풀이 리뷰  Java   TreeMap에 language 값에 맞는 table의 배열을 맞춘 후 preference 값을 더하였다. 이렇게 하면 자동적으로 언어 별 점수의 합이 정렬된다. 이 후 점수 가 큰 순서로 내림차순 한 뒤 첫번째 값을 리턴하였다.  import java.util.*; class Solution { public static void main(String[] args) { Solution solution = new Solution(); String[] table = { \u0026#34;BI JAVA JAVASCRIPT SQL PYTHON C#\u0026#34;, \u0026#34;AONTENTS JAVASCRIPT JAVA PYTHON SQL C++\u0026#34;, \u0026#34;HARDWARE C C++ PYTHON JAVA JAVASCRIPT\u0026#34;, \u0026#34;AORTAL JAVA JAVASCRIPT PYTHON KOTLIN PHP\u0026#34;, \u0026#34;GAME C++ C# JAVASCRIPT C JAVA\u0026#34; }; String[] languages = { \u0026#34;JAVA\u0026#34;, \u0026#34;JAVASCRIPT\u0026#34; }; int[] preference = { 7, 5 }; String result = solution.solution(table, languages, preference); System.out.println(\u0026#34;결과 : \u0026#34; + result); } public String solution(String[] table, String[] languages, int[] preference) { Map\u0026lt;String, Integer\u0026gt; jobResultMap = new TreeMap\u0026lt;String, Integer\u0026gt;(); // ValueComparator bvc = new ValueComparator(jobResultMap);  // TreeMap\u0026lt;String, Integer\u0026gt; sortedMap = new TreeMap\u0026lt;String, Integer\u0026gt;(bvc);  int tableCount = table.length; for (int i = 0; i \u0026lt; tableCount; i++) { String[] splitTable = table[i].split(\u0026#34; \u0026#34;); // 해당 점수별로 값 넣기  jobResultMap.put(splitTable[0], 0); for (int j = 1; j \u0026lt; splitTable.length; j++) { for (int k = 0; k \u0026lt; languages.length; k++) { if (splitTable[j].equals(languages[k])) { jobResultMap.put(splitTable[0], jobResultMap.get(splitTable[0]) + (splitTable.length - j) * preference[k]); } } } } List\u0026lt;String\u0026gt; listKeySet = new ArrayList\u0026lt;\u0026gt;(jobResultMap.keySet()); Collections.sort(listKeySet, (value1, value2) -\u0026gt; (jobResultMap.get(value2).compareTo(jobResultMap.get(value1)))); String answer = listKeySet.get(0); System.out.println(jobResultMap.toString()); System.out.println(listKeySet.toString()); return answer; } } ","permalink":"https://haservi.github.io/posts/algorithms/programmers/level1/02-algo-recommend-job/","summary":"직업군 추천하기 문제 설명 개발자가 사용하는 언어와 언어 선호도를 입력하면 그에 맞는 직업군을 추천해주는 알고리즘을 개발하려고 합니다.\n아래 표는 5개 직업군 별로 많이 사용하는 5개 언어에 직업군 언어 점수를 부여한 표입니다.\n   점수 SI CONTENTS HARDWARE PORTAL GAME     5 JAVA JAVASCRIPT C JAVA C++   4 JAVASCRIPT JAVA C++ JAVASCRIPT C#   3 SQL PYTHON PYTHON PYTHON JAVASCRIPT   2 PYTHON SQL JAVA KOTLIN C   1 C# C++ JAVASCRIPT PHP JAVA    예를 들면, SQL의 SI 직업군 언어 점수는 3점이지만 CONTENTS 직업군 언어 점수는 2점입니다.","title":"[프로그래머스]직업군 추천하기"},{"content":"비밀지도 문제 설명 네오는 평소 프로도가 비상금을 숨겨놓는 장소를 알려줄 비밀지도를 손에 넣었다.\n그런데 이 비밀지도는 숫자로 암호화되어 있어 위치를 확인하기 위해서는 암호를 해독해야 한다.\n다행히 지도 암호를 해독할 방법을 적어놓은 메모도 함께 발견했다.\n 지도는 한 변의 길이가 n인 정사각형 배열 형태로, 각 칸은 \u0026ldquo;공백\u0026rdquo;(\u0026quot; \u0026ldquo;) 또는 \u0026ldquo;벽\u0026rdquo;(\u0026quot;#\u0026quot;) 두 종류로 이루어져 있다. 전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 각각 \u0026ldquo;지도 1\u0026quot;과 \u0026ldquo;지도 2\u0026quot;라고 하자.\n지도 1 또는 지도 2 중 어느 하나라도 벽인 부분은 전체 지도에서도 벽이다.\n지도 1과 지도 2에서 모두 공백인 부분은 전체 지도에서도 공백이다. \u0026ldquo;지도 1\u0026quot;과 \u0026ldquo;지도 2\u0026quot;는 각각 정수 배열로 암호화되어 있다. 암호화된 배열은 지도의 각 가로줄에서 벽 부분을 1, 공백 부분을 0으로 부호화했을 때 얻어지는 이진수에 해당하는 값의 배열이다.  \n네오가 프로도의 비상금을 손에 넣을 수 있도록, 비밀지도의 암호를 해독하는 작업을 도와줄 프로그램을 작성하라.\n입력 형식 입력으로 지도의 한 변 크기 n 과 2개의 정수 배열 arr1, arr2가 들어온다.\n 1 ≦ n ≦ 16 arr1, arr2는 길이 n인 정수 배열로 주어진다. 정수 배열의 각 원소 x를 이진수로 변환했을 때의 길이는 n 이하이다. 즉, 0 ≦ x ≦ 2n - 1을 만족한다.  출력 형식 원래의 비밀지도를 해독하여 '#', 공백으로 구성된 문자열 배열로 출력하라.\n입출력 예제    매개변수 값     n 5   arr1 [9, 20, 28, 18, 11]   arr2 [30, 1, 21, 17, 28]   출력 [\u0026quot;#####\u0026rdquo;,\u0026quot;# # #\u0026rdquo;, \u0026ldquo;### #\u0026rdquo;, \u0026ldquo;# ##\u0026rdquo;, \u0026ldquo;#####\u0026quot;]       매개변수 값     n 6   arr1 [46, 33, 33 ,22, 31, 50]   arr2 [27 ,56, 19, 14, 14, 10]   출력 [\u0026quot;######\u0026rdquo;, \u0026ldquo;### #\u0026rdquo;, \u0026ldquo;## ##\u0026rdquo;, \u0026quot; #### \u0026ldquo;, \u0026quot; #####\u0026rdquo;, \u0026ldquo;### # \u0026ldquo;]    문제 풀이 리뷰  각각의 미로의 길을 이진화 한다. 만약 이진수의 값의 앞 공백이 있는 경우 \u0026ldquo;0\u0026quot;을 추가해준다. 서로 비교하여 0인 경우는 \u0026quot; \u0026ldquo;, 그렇지 않은 경우 \u0026ldquo;#\u0026ldquo;을 추가해준다.  해결 코드 import java.util.*; class Solution { public static void main(String[] args) { Solution solution = new Solution(); int n = 5; int[] arr1 = { 9, 20, 28, 18, 11 }; int[] arr2 = { 30, 1, 21, 17, 28 }; String[] result = solution.solution(n, arr1, arr2); System.out.println(\u0026#34;결과 : \u0026#34; + Arrays.toString(result)); } public String[] solution(int n, int[] arr1, int[] arr2) { String[] answer = new String[n]; // 경로를 십진수를 이진수로 변경 및 이진수 앞 공백 추가  int count = n; for (int i = 0; i \u0026lt; count; i++) { String firstKeyMap = makeZero(Integer.toBinaryString(arr1[i]), count); String secondKeyMap = makeZero(Integer.toBinaryString(arr2[i]), count); String rowKey = \u0026#34;\u0026#34;; // System.out.println(firstKeyMap);  for (int j = 0; j \u0026lt; count; j++) { if ((firstKeyMap.charAt(j) == \u0026#39;0\u0026#39;) \u0026amp;\u0026amp; (secondKeyMap.charAt(j) == \u0026#39;0\u0026#39;)) { rowKey += \u0026#34; \u0026#34;; } else { rowKey += \u0026#34;#\u0026#34;; } } // System.out.println(rowKey);  answer[i] = rowKey; } return answer; } private String makeZero(String binaryString, int length) { int binaryLength = binaryString.length(); while (binaryLength != length) { binaryString = \u0026#34;0\u0026#34; + binaryString; binaryLength++; } return binaryString; } } ","permalink":"https://haservi.github.io/posts/algorithms/programmers/level1/01-algo-secret-map/","summary":"비밀지도 문제 설명 네오는 평소 프로도가 비상금을 숨겨놓는 장소를 알려줄 비밀지도를 손에 넣었다.\n그런데 이 비밀지도는 숫자로 암호화되어 있어 위치를 확인하기 위해서는 암호를 해독해야 한다.\n다행히 지도 암호를 해독할 방법을 적어놓은 메모도 함께 발견했다.\n 지도는 한 변의 길이가 n인 정사각형 배열 형태로, 각 칸은 \u0026ldquo;공백\u0026rdquo;(\u0026quot; \u0026ldquo;) 또는 \u0026ldquo;벽\u0026rdquo;(\u0026quot;#\u0026quot;) 두 종류로 이루어져 있다. 전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 각각 \u0026ldquo;지도 1\u0026quot;과 \u0026ldquo;지도 2\u0026quot;라고 하자.\n지도 1 또는 지도 2 중 어느 하나라도 벽인 부분은 전체 지도에서도 벽이다.","title":"[프로그래머스]비밀지도"},{"content":"블로그 시작하기 최근 기억하는 것보다 잊혀져가는 것이 많아져 공부한 내용을 기록하기 위해 블로그를 다시 써보려 합니다.\n이전에 티스토리에서 블로그를 했었는데 뭐랄까.. github에서 하는게 좀 더 관리하기가 편할 것 같아 이사하게 됐습니다. :D\n주로 공부한 내용 또는 삽질 그리고 개발하면서 도움되는 팁에 대한 내용이 주를 이룰 것이라 생각합니다.\n테마 선정 gihtub.io 안에서도 Gatsby, Jekyll, Hexo, Hugo와 같은 여러 테마가 있으며 이 중 Hugo를 사용하고 있습니다.\n해당 블로그 테마는 PaperMod를 기본으로 하였으며, 조금 커스텀하여 사용중입니다.\n바라는 점 제가 쓴 글이 다른분들에게 조금이나마 도움이 되면 좋겠습니다.😊\n또한, 제가 작성한 글이 잘못된 것일 수도 있습니다. 잘못된 내용이 있으면 언제든지 댓글 또는 피드백 부탁드립니다.\n","permalink":"https://haservi.github.io/posts/etc/start-blog/","summary":"블로그 시작하기 최근 기억하는 것보다 잊혀져가는 것이 많아져 공부한 내용을 기록하기 위해 블로그를 다시 써보려 합니다.\n이전에 티스토리에서 블로그를 했었는데 뭐랄까.. github에서 하는게 좀 더 관리하기가 편할 것 같아 이사하게 됐습니다. :D\n주로 공부한 내용 또는 삽질 그리고 개발하면서 도움되는 팁에 대한 내용이 주를 이룰 것이라 생각합니다.\n테마 선정 gihtub.io 안에서도 Gatsby, Jekyll, Hexo, Hugo와 같은 여러 테마가 있으며 이 중 Hugo를 사용하고 있습니다.\n해당 블로그 테마는 PaperMod를 기본으로 하였으며, 조금 커스텀하여 사용중입니다.","title":"블로그 시작하기"}]