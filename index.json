[{"content":"프로젝트 중 LwM2M과 Anjay의 통신이 간헐적으로 끊기는 현상이 발생하여 이와 관련하여 프로토콜의 개념에 대해 알아보고, 와이어샤크를 이용해 DTLS handshake를 확인한 내용입니다.\nLwM2M에 대해 LwM2M (Lightweight M2M)은 경량화된 기기 간 통신 프로토콜로서, IoT (Internet of Things) 기기와 서버 간의 효율적인 통신을 위해 설계되었습니다.\nLwM2M은 경량화된 프로토콜로, 리소스 제약이 있는 IoT 기기에서도 효율적으로 동작합니다. 작은 패킷 크기와 최소한의 대역폭을 사용하여 효율적인 통신을 제공합니다.\nLwM2M은 RESTful 아키텍처를 기반으로 하며, HTTP/CoAP 프로토콜을 사용하여 기기와 서버 간 통신을 지원합니다.\nAnjay에 대해 Anjay는 LwM2M 프로토콜을 구현한 오픈 소스 라이브러리로, C 언어로 작성되었습니다. 주로 임베디드 시스템 및 경량 IoT 장치에서 사용됩니다.\nAnjay는 임베디드 디바이스에서 CoAP(Constrained Application Protocol)을 구현하기 위한 오픈 소스 라이브러리입니다. CoAP는 저전력 비동기 통신 프로토콜 입니다. UDP를 기반으로 비동기 통신을 사용합니다. Anjay는 mbedTLS를 사용하여 보안 기능을 제공합니다.\nmbedTLS를 사용하여 보안 기능을 통합하는 것은 Anjay의 디바이스 측 보안 기능을 강화하는 데 도움이 되며, DTLS (Datagram Transport Layer Security)를 통한 CoAP 통신을 안전하게 구현하는 데 적합합니다.\nmbedTLS 란 mbedTLS는 오픈 소스의 암호 라이브러리로, TLS(Transport Layer Security) 및 SSL(Secure Sockets Layer) 프로토콜을 구현하는 데 사용됩니다.\nTLS 및 SSL은 네트워크 통신을 보안하고 데이터를 암호화하는 데 사용되는 프로토콜로, 주로 웹 서버 및 클라이언트 간의 안전한 통신을 제공하는 데 사용됩니다.\nmbed TLS는 C 언어로 작성된 라이브러리로, 경량이며 임베디드 시스템 및 리소스 제한된 환경에서도 사용할 수 있도록 설계되었습니다. 이 라이브러리를 사용하면 암호화, 디지털 서명, 인증 및 안전한 통신을 구현하는 데 도움을 줍니다.\nmbed TLS안에는 DTLS 1.2 기능이 포함돼 있습니다.\nRFC 9146의 문서에서는 DTLS 1.2에 연결 식별자를 추가하는 방법에 대한 표준이 정의돼 있습니다.\n연결 식별자를 CID라고 하며, 아래와 같이 연결 식별자의 형식과 사용 방법에 대한 예제가 나옵니다.\n예제는 아래와 같습니다.\n구현 과정 중 문제점 문제는 RFC 9146의 예제 문서대로라면 위와 같이 돼야 하는데 와이어 샤크로 확인했을 때는 위의 예제처럼 동작하지 않았습니다.\n공식 문서와 스택오버플로우, 구글링을 통해 확인해보니 결론적으로 LwM2M과 Anjay의 통신 설정을 문서를 참조하여 올바르게 설정 해야합니다.\n이렇게 Server(LwM2M)와 Client(Anjay)가 정상적으로 통신하면 아래와 같이 위의 예제 문서와 동일하게 출력한 걸 확인할 수 있습니다.\n위와 같이 Client에서는 ClientHello의 신호를 Server에 보내고 Server에서는 HelloVerifyRequest로 Client에 요청합니다.\nClient는 위 값을 받고 다시 Server에게 ConnectionID를 요청합니다. Server는 내부적으로 ConnectionId(c89be44b77a2)를 만들어서 Client에게 전달합니다.\n그렇게 ConnectionId(c89be44b77a2)를 받은 Client는 해당 값을 다시 Server에게 ConnectionId(c89be44b77a2)를 확인 받은 뒤에 해당 ConnectionId를 이용하여 통신을 합니다.\n위의 handshake 절차를 통해 정상적으로 연결을 유지할 수 있습니다.\n아래는 와이어 샤크로 통신한 내용의 세부 내용입니다.\nClinet(ClientHello) Server(HelloVerifyRequest) Client(ClientHello - CID 요청) Server(ServerHello - CID 제공) Client(Server에 해당 CID 재확인 요청) Server(인증 완료) Client(CID를 이용해 통신) 와이어 샤크를 실제로 자주 사용한 적은 없지만 네트워크 패킷을 분석하여 여러 상황에서 유용하게 쓸 수 있는 도구라고 생각됩니다.\n참고 DTLS 1.2 RFC 9146 문서 ","permalink":"https://haservi.github.io/posts/tips/wireshark-dtls-handshake/","summary":"프로젝트 중 LwM2M과 Anjay의 통신이 간헐적으로 끊기는 현상이 발생하여 이와 관련하여 프로토콜의 개념에 대해 알아보고, 와이어샤크를 이용해 DTLS handshake를 확인한 내용입니다.\nLwM2M에 대해 LwM2M (Lightweight M2M)은 경량화된 기기 간 통신 프로토콜로서, IoT (Internet of Things) 기기와 서버 간의 효율적인 통신을 위해 설계되었습니다.\nLwM2M은 경량화된 프로토콜로, 리소스 제약이 있는 IoT 기기에서도 효율적으로 동작합니다. 작은 패킷 크기와 최소한의 대역폭을 사용하여 효율적인 통신을 제공합니다.\nLwM2M은 RESTful 아키텍처를 기반으로 하며, HTTP/CoAP 프로토콜을 사용하여 기기와 서버 간 통신을 지원합니다.","title":"와이어 샤크를 이용해 DTLS1.2 handshake 확인하기"},{"content":"스프링 프로젝트 중 공통적인 처리에 대한 방법 및 코드 개선에 대한 내용에 대한 정리입니다.\n알림\n해당 글은 Spring으로 사내 프로젝트를 하면서 느낀 코드 개선 및 경험에 대한 내용입니다.\n여러 개발 블로그의 경험과 노하우가 담긴 글을 참조하며, 추가한 내용입니다.\n글의 내용이 정답이 아닐 수 있으며, 개인적인 생각으로 가볍게 읽어주세요. :D..\n프로젝트 코드 공통 처리 및 여러 Tips 참조링크 : Spring Guide - Directory\n최근 프로젝트의 구조는 아래와 같습니다.\n위와 같이 패키지를 domain과 global로 나누어 환경을 구축했습니다.\ndomain에서는 front의 화면과 유사하게 package를 설정했습니다.\n하지만 프로젝트의 시나리오가 자주 변경되고 각 시스템에서 공통적인 로직들이 많아지면서 중복 코드가 발생하게 되면서 구조를 조금 변경했습니다.\nbackend의 경우 시스템 저장소가 7개 정도가 되다보니 아무래도 중복 코드가 많이 발생했습니다.\n그래서 global은 모든 프로젝트(각각의 repository)를 동일하게 맞춘 후 multi module 또는 git submodule을 활용하여 관리하고 코드를 수정합니다.\n기존 global에 있는 시스템마다 조금 씩 다른 Spring Security 설정 Swaager 설정은 global에서 domain package로 이동 시켰습니다.\n또한, 하나의 Class 안에 시스템별 Inner Class가 있었던 부분이 있는데 코드를 유지관리하기가 힘들어서 전부 분리했습니다.\ndomain에서는 시스템 별 API 구조 포멧이 동일한 경우 front의 component개념과 동일하게 다른 backend 저장소에서도 해당 package를 복사하여도 import 경로 충돌이 없도록 구조를 맞추어 작업을 하게 되니 조금 더 공수가 줄어드는 효과가 있습니다.\nResponse Template에 대한 처리 참조링크: Response를 객체에 담아 반환하기\n참조링크: Spring Guide - Exception 전략\nFront에 제공하는 API의 통일성을 위하여 API 제공 시에 일관된 구조로 제공하기 위해 처음 의도는 정상적으로 API의 템플릿과 오류 및 유효성 처리에 대한 템플릿을 구분하여 처리합니다.\n정상 템플릿 1 2 3 \u0026#34;success\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;data\u0026#34;: \u0026#34;\u0026#34; 에러 템플릿 1 2 3 4 \u0026#34;success\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;error_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;error_list\u0026#34;: \u0026#34;\u0026#34; 위와 같은 템플릿으로 backend에서는 정상인 경우 controller에서 return 해버리고 비정상적인 경우 @valid에서 죽거나, error를 throw합니다.\n이렇게 구현하면 아래와 같이 controller에서 바로 로직을 처리할 수 있습니다.\n1 2 3 4 @PostMapping public SingleResult\u0026lt;TempManageResponse\u0026gt; getTempList(@Valid @RequestBody TempRequest request) { return responseService.getSingleResult(tempManageService.getTempList(request), TEMP_SELECT_SUCCESS); } 에러의 경우 처리는 아래와 같습니다. 이후 ExceptionHandler로 빠진다음 여기서 error template 함수를 통해 에러 메시지를 반환합니다.\n1 2 Temp temp = tempRepository.findBySnoAndUseYn(request.getTempSno(), SEARCH_USE_YN) .orElseThrow(() -\u0026gt; new EntityNotFoundException(TEMP_NOT_FOUND)) 이렇게 하면 에러에 대한 처리를 핸들링 할 수 있으니 필요에 의해 맞출 수 있습니다.\nentity에서 enum을 써야할 경우 참조링크: Legacy DB의 JPA Entity Mapping (Enum Converter 편)\nenum 처리는 약간 고민이 드는 점이 있지만 enum의 경우도 정말 잘 사용한다면 여러 상태를 직관적이고 쉽게 처리하고 화면과 상태를 한번에 처리할 수 있기에 장점이 있습니다.\n단점이라면 조금 학습을 해야하며, 종종 enum을 이용한 entity를 처리를 하면 다른 시스템에서 비슷한 시스템이지만 entity 정의가 달라서 코드 로직이 다른 경우입니다.\n예를 들어 아래의 entity가 있다고 하면,\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Convert(converter = AlarmConverter.class) @Comment(\u0026#34;100:알림-일반, 200:알림-정상, 300:알림-경고, 400:알림-심각\u0026#34;) @Column(name = \u0026#34;alarm_code\u0026#34;) private AlarmStatus alarm; ... @Getter public enum AlarmStatus implements EnumType { ALARM(100, \u0026#34;알림\u0026#34;, 0), NORMAL(200, \u0026#34;정상\u0026#34;, 0), WARNING(300, \u0026#34;경고\u0026#34;, 1), FATAL(400, \u0026#34;심각\u0026#34;, 2), ; private final int code; private final String level; private final int levelCode; ... } 1 2 3 @Comment(\u0026#34;100:알림-일반, 200:알림-정상, 300:알림-경고, 400:알림-심각\u0026#34;) @Column(name = \u0026#34;alarm_code\u0026#34;) private int alarm; 이렇게 다른 시스템에서 정의한 entity가 다른 경우 관련된 로직도 달라집니다.\n간단한 예로 해당 entity의 상태값을 조회할 때도 entity에 enum을 정의한 경우 아래와 같이\n1 2 3 4 5 6 7 8 9 10 @QueryProjection public NotificationsData(Long notiSno, NotificationsStatus status, String equip, LocalDateTime dateTime, String value, NotificationsConfirmStatus confirmationStatus) { this.notiSno = notiSno; this.level = status.getLevel(); this.equip = equip; this.dateTime = dateTime; this.value = value; this.confirmationStatus = confirmationStatus.getDesc(); } enum이 상태를 알기에 세부적으로 지정한 정보를 바로 가져올 수 있습니다.\nentity의 단일 타입으로 설정하면 enum에서 정의하지 못한 값을 상수로 정의 후 조건문으로 확인하는 로직이 필요합니다.\n하지만 이것도 정답이 있는 것이 아니라 프로젝트의 복잡도와 어떻게 하는게 더 쉽고 효율적인지에 따라 상황에 맞게 팀내에서 잘 조율해서 해야 된다고 생각합니다.\nDto 및 Optional은 잘 사용하기 관령링크: Optional에 대해\nbackend의 controller의 역할은 frontend에서 들어온 값의 유효성 처리와 service 로직에 필요한 값을 제공하거나, 반대로 frontend에 데이터를 제공하는 경우라 생각합니다.\n여러 블로그를 보면 dto는 controller와 service까지만 관여하는게 좋다고도 하는데 QueryDSL을 이용하므로 dto는 repository 까지 들어가는 경우도 종종 있을 수 있다고 생각합니다.\n이러한 부분은 유연하게 가면 될 것이라 생각됩니다.\n관리할 수 없는 코드는 삭제 처음 Backend를 구성할 때는 swagger2를 적용하고 front 외주 개발자 분과 API에 대한 기능을 명세했었습니다.\nswagger2에서는 실시간으로 backend api를 확인할 수 있지만, 그 때에 이슈 및 요청사항 관리를 어떻게 할지 고민중에\n어떤 API가 변경됐는지를 swagger안에 html을 만들어서 명세 했던적이 있습니다.\n1 2 3 4 5 6 7 8 9 10 private ApiInfo apiInfo() { return new ApiInfoBuilder() .title(\u0026#34;title\u0026#34;) .version(\u0026#34;1.01\u0026#34;) .description(\u0026#34;설명\u0026#34;) .license(\u0026#34;변경이력 \u0026#34;) .licenseUrl(\u0026#34;/version-history.html\u0026#34;) .build(); } 위와 같이 설정 후 static에 github style을 적용 후 html에 변경 이력을 관리했습니다.\n문제는 회의 후 수정사항이 증가하면 위의 변경이력 또한 갱신해줘야 하는데 일을 하기 위해 일을 만드는 거라 느껴졌습니다.\n지금은 Gitlab에서 CI/CD와 각 시스템마다 Issue를 처리하고 있지만, 이슈에 대해 이슈 트래킹 도구(Jira or Trello or Gitlab or Notion 등)를 미리 이용했다면 더 좋았을 거라 생각됩니다.\n클래스 역할 코드는 각 클래스의 역할에 맞게 코드를 분리하면 좋다고 생각합니다.\n예를 들어, 회원가입을 하는 경우 controller에서는 입력값에 대한 유효성 처리, service에서는 db와 연계된 예외사항 및 로직 처리, repository는 실제 저장할 쿼리 정도로 기준을 잡아서 처리합니다.\nDto에서 유효성을 처리하는 방법은 아래와 같으며, 컨트롤러에서는 아래와 같이 처리하면 좋습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 Controller public CommonResult updateUser(@Valid @RequestBody UserUpdateRequest request) { userManageService.updateUser(request); return responseService.getSuccessResult(CommonMessage.USER_UPDATE_SUCCESS); } Request Dto @Getter @NoArgsConstructor(access = AccessLevel.PRIVATE) @ApiModel(value = \u0026#34;사용자 수정 요청 정보\u0026#34;) public class UserUpdateRequest { @NotBlank(message = \u0026#34;이름을 입력하세요.\u0026#34;) private String name; @Email(message = \u0026#34;유효한 이메일 주소를 입력하세요.\u0026#34;) private String email; } 위와 같이 지정하면 위에서 지정한 Global Exception으로 해당 valid가 빠지면서 에러 템플릿에서 지정한 포맷으로 에러 사유를 볼 수 있습니다.\n이 밖에도 필요에 따라 페이징 처리, 다국어 처리, DB 이중화 등도 잘 설정해 놓으면 쉽게 이용하여 쓸 수 있을 것이라 생각합니다.\n","permalink":"https://haservi.github.io/posts/spring/spring-project-structure-proecess/","summary":"스프링 프로젝트 중 공통적인 처리에 대한 방법 및 코드 개선에 대한 내용에 대한 정리입니다.\n알림\n해당 글은 Spring으로 사내 프로젝트를 하면서 느낀 코드 개선 및 경험에 대한 내용입니다.\n여러 개발 블로그의 경험과 노하우가 담긴 글을 참조하며, 추가한 내용입니다.\n글의 내용이 정답이 아닐 수 있으며, 개인적인 생각으로 가볍게 읽어주세요. :D..\n프로젝트 코드 공통 처리 및 여러 Tips 참조링크 : Spring Guide - Directory\n최근 프로젝트의 구조는 아래와 같습니다.\n위와 같이 패키지를 domain과 global로 나누어 환경을 구축했습니다.","title":"Spring 프로젝트 구조 및 공통 코드 처리 방법"},{"content":"프로젝트를 하다보면 성능 개선을 위해 어느 쿼리가 얼마나 걸리고, 어떻게 쿼리를 호출하는지 확인해야 할 경우가 있습니다.\nJPA QueryDSL을 이용할 때 여러 조인과 entity의 관계를 정의하다 보면 생각하지 못한 부분에서 속도가 매우 느린 경우도 있고, 대용량으로 데이터가 들어오면 잘 되던 쿼리가 느려질 때도 있습니다.\n이럴때 p6spy를 이용하여 쿼리를 보기 좋고, 얼마나 걸리는지 확인할 수 있는 방법에 대해 정리했습니다.\n위의 저장소에서 쿼리를 로그에 출력할 수 있는 간단한 h2 CRUD 예제 코드를 작성했습니다.\n위의 예제를 실행하면 아래와 같이 쿼리를 수행함을 확인할 수 있습니다.\np6Spy는 기존 코드의 변경 없이 SQL 로그를 출력해주는 프레임워크 입니다.\n주요 포인트는 p6Spy에서 제공하는 인터페이스 중 MessageFormattingStrategy 파일을 상속 받아 해당 메서드를 override 하여 사용합니다.\n아래의 사진과 같이 전략 패턴(Strategy Pattern)을 이용하여 프로그램 런타임 시 기존의 @PostConstruct를 사용하여 미리 정의된 formatMessage를 이용합니다.\n공식 문서에서 제공하는 많은 기능 중 필요한 기능만 spy.properties에 정의합니다.\n1 2 3 appender=com.p6spy.engine.spy.appender.Slf4JLogger logMessageFormat=com.p6spy.engine.spy.appender.CustomLineFormat customLogMessageFormat=| %(executionTime) ms | %(sql) 기본적으로 application.yml에서 쿼리 로그를 ON/OFF 할 수 있습니다.\n1 2 3 4 decorator: datasource: p6spy: enable-logging: true 위와 같이 설정을 하고 P6SpySqlFormatterConfig 클래스 파일에서 시간 초과 기준을 정하면 쿼리의 실행 속도 및 수행한 쿼리를 쉽게 확인할 수 있으며, 어디에서 문제가 발생했는지 쉽게 확인할 수 있으니, 쿼리 성능 개선을 조금 더 편하게 할 수 있을 것이라 생각합니다.\n참고 P6Spy 쿼리 로그 출력하기 [Spring Boot JPA] P6Spy 활용해 쿼리 로그 확인하기 p6Spy 공식문서 ","permalink":"https://haservi.github.io/posts/spring/p6-spy-query-log/","summary":"프로젝트를 하다보면 성능 개선을 위해 어느 쿼리가 얼마나 걸리고, 어떻게 쿼리를 호출하는지 확인해야 할 경우가 있습니다.\nJPA QueryDSL을 이용할 때 여러 조인과 entity의 관계를 정의하다 보면 생각하지 못한 부분에서 속도가 매우 느린 경우도 있고, 대용량으로 데이터가 들어오면 잘 되던 쿼리가 느려질 때도 있습니다.\n이럴때 p6spy를 이용하여 쿼리를 보기 좋고, 얼마나 걸리는지 확인할 수 있는 방법에 대해 정리했습니다.\n위의 저장소에서 쿼리를 로그에 출력할 수 있는 간단한 h2 CRUD 예제 코드를 작성했습니다.","title":"P6Spy를 이용하여 로그 출력하기"},{"content":"토비의 스프링 저자로 유명한 토비님이 인프런에 강의를 만드셔서 수강해봤습니다.\n인프런 강의 중 김영한 님의 강의가 실제 실무에 큰 도움이 된 것 같다면, 토비님의 강의는 스프링 부트에 대해 조금 더 깊이 있게 알아보는게 목적이었던 것 같습니다.\n기존 강의에서는 Spring Boot 2.7과 jdk 11로 했지만 학습 코드는 Spring Boot 3.1.1과 jdk 17로 적용해서 클론 코딩을 진행하며 버전이 달라지면서 발생한 문제와 팁을 정리했습니다.\n강의에서 나온 프로그램 추천 sdkman: jdk 및 여러 sdk들의 버전을 쉽게 변경할 수 있도록 해준다.\nWrap: AI가 내장된 터미널(다양한 기능 있음)\nhttpie: 터미널에서 간단한 api 응답 요청이 가능하다.\n1 http -v \u0026#34;:8080/hello?name=Spring Code Style은 intellij-java-google-style.xml로 적용했습니다.\n관련 링크 입니다.\n강의 클론 코딩 중 발생한 이슈 버전이 달라서 발생한 문제\nspring boot 3.1.1을 적용하면서 @RequestMapping이 있어도 스프링 컨트롤러로 인식하지 않는 현상이 있습니다.\n@RestController, @Controller 애노테이션이 있어야 스프링 컨트롤러로 인식합니다.\n스프링 boot 3.0부터는 클래스 레벨의 핸들러 감지 대상이 @Controller만 포함 됨 Github Issue 변경 사항 API를 통한 테스트 중 port가 안맞는 문제\n1 2 org.springframework.web.client.ResourceAccessException: I/O error on GET request for \u0026#34;http://localhost:8080/hello\u0026#34;: Connection refused ... 와 같은 에러 발생하여 테스트 클래스 상단에 @SpringBootTest(webEnvironment = WebEnvironment.DEFINED_PORT) 어노테이션 추가 -\u0026gt; 관련 링크\njetty를 config로 지정할 때 아래와 같은 에러가 발생한 경우\n1 2 3 4 5 ... at tobyspring.helloboot.HelloBootApplication.main(HelloBootApplication.java:15) ~[classes/:na] Caused by: java.lang.NoClassDefFoundError: jakarta/servlet/http/HttpSessionContext at org.eclipse.jetty.servlet.ServletContextHandler.newSessionHandler(ServletContextHandler.java:339) ~[je ... spring-boot-starter-jetty 의존성 관련된 문제로 판단된다. Spring Boot 3에서는 Jakarta Servlet 6.0.0이고, spring-boot-starter-jetty는 Jakarta Servlet 5.0.0이라 발생하는 문제로 판단 일단 해결하기 위해서 build.gradle에 종속성 하나를 더 추가 했었습니다.\n1 implementation group: \u0026#39;org.eclipse.jetty\u0026#39;, name: \u0026#39;jetty-servlet\u0026#39;, version: \u0026#39;11.0.15\u0026#39; 조금 더 찾아보니 스프링부트에 이슈로 있으며, build.gradle에서\n1 ext[\u0026#39;jakarta-servlet.version\u0026#39;] = \u0026#39;5.0.0\u0026#39; 를 명시적으로 써주면 된다고하여 수정했습니다.\n버전이 안맞는 문제 링크\nHikari-cp 설정이 잘안되는 현상\n1 implementation(\u0026#39;com.zaxxer:HikariCP:4.0.3\u0026#39;) // 이렇게 하니 잘됨.. 환경 설정을 통해 env 우선 순위를 정할 수 있다 위와 같이 설정한 경우 기존 application.properties보다 더 높은 우선순위를 지정할 수 있다.\nVM Option \u0026gt; Environment variables \u0026gt; application.properties 순으로 우선순위가 정해진다.\n추가 팁 gradle 라이브러리 디펜더시 확인\n1 ./gradlew dependencies --configuration compileClasspath 스프링 부트 스타터 공식 문서\n코드에서 Comaparator.java 인터페이스를 보면 좋다고 함\n","permalink":"https://haservi.github.io/posts/review/inflearn-toby-spring/","summary":"토비의 스프링 저자로 유명한 토비님이 인프런에 강의를 만드셔서 수강해봤습니다.\n인프런 강의 중 김영한 님의 강의가 실제 실무에 큰 도움이 된 것 같다면, 토비님의 강의는 스프링 부트에 대해 조금 더 깊이 있게 알아보는게 목적이었던 것 같습니다.\n기존 강의에서는 Spring Boot 2.7과 jdk 11로 했지만 학습 코드는 Spring Boot 3.1.1과 jdk 17로 적용해서 클론 코딩을 진행하며 버전이 달라지면서 발생한 문제와 팁을 정리했습니다.\n강의에서 나온 프로그램 추천 sdkman: jdk 및 여러 sdk들의 버전을 쉽게 변경할 수 있도록 해준다.","title":"Inflearn 토비의 스프링 부트 강의 후기 및 정리"},{"content":"이전에 진행 중인 프로젝트에서는 Code Convention이 지켜지지 않아 코드 정렬이 좋지 않은 경우가 있었습니다.\n이는 여러 담당자를 거치면서 코드의 가독성이 떨어지고 코드 수정 이후 git history를 확인하기 어렵게 만들었습니다.\n이 문제를 해결하기 위해서는 모든 코드를 동일한 Format으로 변경하는 설정을 해야 합니다. 일반적으로 Prettier와 EsLint는 함께 사용됩니다.\nESLint는 코드의 퀄리티를 보장하도록 도와주는 도구입니다. 일관성 있는 방식으로 코드를 구현할 수 있게 됩니다. 예를 들어 함수를 표현할 때 function을 이용할지 arrow를 이용할지 등을 정할 수 있습니다.\nPrettier는 코드 구현과는 관련없이 일관된 방식의 코드 포맷을 정리하게 도와주는 도구입니다. 띄어쓰기 4칸 또는 2칸 등과 같은 것을 일관되게 적용합니다.\n해당 프로젝트 이전 코드의 코드 포맷을 맞추고 이후 코드 수정에서 일관성을 지키기 위해 Prettier만을 이용하여 간단하게 정의하고 추후 변경된 코드는 .prettierrc 설정으로 일관성 있는 코드 작성을 유지하도록 설정하도록 합니다.\n다음은 Prettier만을 이용하여 프로젝트 코드포맷을 변경하는 방법입니다.\nPrettier 설정 방법 우선 VS Code를 기준으로 설정합니다.\n확장관리자에서 Pretiier - Code formatter와 Vue Language Features (Volar)를 설치합니다.\n코드 적용을 하고 싶은 프로젝트 최상단에 아래와 같은 .prettierrc파일을 생성합니다. 아래의 옵션 외에 다양한 옵션이 공식 홈페이지에\n문서화돼 있으므로 참조할 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \u0026#34;singleQuote\u0026#34;: true, // 작은 따옴표 사용(문자열) \u0026#34;semi\u0026#34;: true, // 문장 뒤에 세미콜론 추가 \u0026#34;useTabs\u0026#34;: false, // tab 허용 안함 \u0026#34;tabWidth\u0026#34;: 2, // tab 길이 2칸 \u0026#34;trailingComma\u0026#34;: \u0026#34;all\u0026#34;, // 배열, 객체 속성에서 마지막 요소 컴마 사용 \u0026#34;printWidth\u0026#34;: 120, // 코드의 블록 너비 \u0026#34;bracketSpacing\u0026#34;: true, // 객체 리터럴 공백 추가 { foo: bar } \u0026#34;overrides\u0026#34;: [ { \u0026#34;files\u0026#34;: \u0026#34;*.vue\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;parser\u0026#34;: \u0026#34;vue\u0026#34; } ] // vue 파일의 경우 vue parser로 구문 분석기 지정 } command + , 또는 ctrl + ,를 이용해 설정으로 이동 후 json script로 이동하여 아래와 같이 스크립트를 추가해줍니다.\nVue의 경우 prettier의 자동완성이 설정되지 않아 이렇게 명시적으로 넣어줘야 합니다.\n1 2 3 \u0026#34;[vue]\u0026#34;: { \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;esbenp.prettier-vscode\u0026#34; } 위 설정을 마친 후 기존에 있던 vue와 js파일 또는 ts가 있다면 아래에 ts를 추가하여 명령어를 src위치에서 쓰면 모든 파일이 한번에 수정할 수 있습니다.Title\n1 npx prettier --write **/*.{js,vue} # 이게 안되면 {} 제거 후 각각 실행 VsCode에서 저장 시 자동으로 포맷을 저장하도록 설정합니다. command + , 또는 ctrl + ,을 눌러 설정창에서 Format on Save를 선택합니다.\n이렇게 한번 지정하면 이후에는 코드 포맷에 대한 고민을 조금은 덜 수 있습니다.\n참조 Prettier 문서 ","permalink":"https://haservi.github.io/posts/tips/vue-code-convetion/","summary":"이전에 진행 중인 프로젝트에서는 Code Convention이 지켜지지 않아 코드 정렬이 좋지 않은 경우가 있었습니다.\n이는 여러 담당자를 거치면서 코드의 가독성이 떨어지고 코드 수정 이후 git history를 확인하기 어렵게 만들었습니다.\n이 문제를 해결하기 위해서는 모든 코드를 동일한 Format으로 변경하는 설정을 해야 합니다. 일반적으로 Prettier와 EsLint는 함께 사용됩니다.\nESLint는 코드의 퀄리티를 보장하도록 도와주는 도구입니다. 일관성 있는 방식으로 코드를 구현할 수 있게 됩니다. 예를 들어 함수를 표현할 때 function을 이용할지 arrow를 이용할지 등을 정할 수 있습니다.","title":"Vue Prettier로 코드 정렬하기"},{"content":"Udemy 강의중 Docker \u0026amp; Kubernetes 강의를 수강 후 내용 정리 및 리뷰를 작성합니다.\n우선 Udemy는 외국 강의가 많고, 한달에 여러번 할인을 하기에 괜찮은 강의가 있으면 미리 결재해 놓는게 좋습니다.\n강의 후기 Udemy 강의는 할인 가격이 저렴해서 그런지 외국 강의라 그런지 수강률이 높지 않은데 해당 강의는 제가 Udemy에서 수강했었던 강의 중 만족도는 상위권이라 생각합니다.\n주로 Backend 개발자 입장에서 해당 강의로 얻을 수 있는 점은 Docker와 Docker-compose를 이용해 개발 생산성을 높일 수 있다 생각합니다.\n물론 Kubernetes도 충분히 의미가 있었지만 강의에서 그렇게 깊게 다루진 않은 것 같습니다.\n실무에서도 backend 서버 테트를 위해서 종종 front 코드를 열때도 docker-compose를 이용하면 좋습니다.\n위와 같이 front 프로젝트를 소스코드만 바인드 마운트로 설정 후 Docker로 프로젝트를 정의하고, docker-compose를 볼륨 이용해 여러 front 프로젝트를 관리하면 더 이상 node version과 다양한 설정에 대한 고민을 하지 않아 좋습니다.\n강의 내용 정리 클론 코딩을 하며 강의에서 들었던 내용 중 몇몇 내용을 정리했습니다.\n도커 명령어 관련 정보 -p 포트 설정 ex) 3000:80 -\u0026gt; host port:container port -d `detached mode로 도커 컨테이너를 백그라운드에서 실행 --name 컨테이너 이름 지정 --rm 피드백이 중지 시 자동으로 컨테이너 제거 -v 볼륨 지정 명명된 볼륨은 컨테이너가 제거하지 않음 :ro 읽기 전용 -f: 도커 파일명을 지정할 수 있음 도커 내부에서 나의 로컬 호스트를 아는 방법\n1 localhost:port -\u0026gt; host.docker.internal:port docker 명령어 예제\n1 docker run -d -p 3000:80 --rm --name feedback-app -v feedback:/app/feedback -v $(pwd):/app -v /app/node_modules feedback-node 바인드 마운트 단축키\n프로젝트 경로에서 /src만 바인드 마운트 후 docker의 /app 폴더에 바인드 마운트\n1 2 macOS/Linux: -v$(pwd)/src:/app/src Windows: -v ${PWD}/src:/app/src 도커 컨테이너 및 이미지 한번에 제거\n1 2 3 4 docker container prune docker image prune # 이게 안되면 아래거로 docker rmi $(docker images -a -q) docker volume prune Docker Compose 도커 컴포즈 실행\n-d: detached 모드 up \u0026ndash;build: 이미지를 리빌드 1 docker-compose up -d 도커 컴포즈 종료\n-v: 볼륨과 함께 제거 1 docker-compose down -v docker.prod 설정 관련 Docker CMD에서 CMD [ \u0026quot;npm\u0026quot;, \u0026quot;start\u0026quot; ]값은 기본적으로 package.json의 스크립트에 있는 start 명령어를 실행한다.\n이외에는 가운데에 CMD [ \u0026quot;npm\u0026quot;, \u0026quot;run\u0026quot;, \u0026quot;start\u0026quot; ]을 추가해서 스크립트 실행해야한다.\nnginx docker menual을 참조하여 빌드된 파일의 위치를 지정해야 한다.\n멀티스테이지 빌드로 하나의 도커파일에 여러 이미지를 빌드할 수 있다.\n-f: 도커 파일명을 지정할 수 있음\n1 docker build -f frontend/Dockerfile.prod ./frontend 기타 명령어 컨테이너 제거\n1 docker rm [mycontainer] 이미지 제거\n1 docker rmi [myimage] 볼륨 확인\n1 docker volume ls 볼륨 제거\n1 docker volume rm [volume name] AWS에 대해 AWS는 Amazon Web Services의 약어로, 아마존닷컴이 제공하는 클라우드 컴퓨팅 서비스 플랫폼입니다. AWS는 컴퓨팅, 스토리지, 데이터베이스, 분석, 인공지능, IoT 및 기타 다양한 서비스를 제공하여 기업이나 개인이 필요로 하는 IT 인프라를 클라우드 기반으로 구축하고 관리할 수 있도록 도와줍니다. 아래 링크는 AWS에 대한 강사분의 영상 설명 링크입니다.\nAWS에 대한 유튜브 영상 링크\n도커 이미지 공식홈페이지 등록/업데이트/가져오기 도커 이미지 등록\n1 2 3 4 docker login # 로그인 docker build -t node-dep-example . # 이미지 생성 docker tag node-dep-example [docker id]/node-dep-example # 태그 지정 docker push [docker id]/node-dep-example # 푸시 도커 이미지 업데이트 방법\n1 2 3 docker build -t node-dep-example . # 동일한 태그로 등록 docker tag node-dep-example [docker id]/node-dep-example:0.1 # 버전 명시 docker push [docker id]/node-dep-example:0.1 # 푸시 도커 이미지 가져오기\n1 docker pull [docker id]/node-dep-example:0.1 팁으로 도커 이미지의 변화없이 같으면 이미지의 이름은 다르지만 이미지ID가 같아서 삭제가 안되는 경우가 있다. 이럴 때는 아래와 같이 태그를 명시해서 제거할 수 있다.\n1 docker rmi [이미지이름:tag] 쿠버네티스 쿠버네티스에서 사용자가 유의해야 할 것은 클러스터와 노드 생성이다.\nmac apple arm 기준 설치\n1 brew install kubectl VitureBox 설치 후 minikube 설치\n1 2 3 brew install minikube minikube start --driver=virtualbox # 이게 안되면 minikube start --driver=docker # 이거 설치 확인\n1 minikube status 대시보드 확인\n1 minikube dashboard 쿠버네티스의 주요 개념 중 하나는 파드(Pod)입니다.\n파드는 쿠버네티스에서 실행되는 가장 작은 배포 단위이며, 일반적으로 파드는 하나 이상의 컨테이너로 구성되며, 이 컨테이너들은 동일한 호스트에서 동작하고 동일한 네트워크 네임스페이스와 IP 주소를 공유합니다.\nkubectl api-resources를 입력하면 kubectl의 명령어를 어느 정도 확인 할 수 있습니다.\nPod란?\nKubernetes(K8s)에서 Pod는 가장 작은 배포 단위이며, Pod는 K8s 클러스터 내에서 실행되는 하나 이상의 컨테이너 그룹입니다. Pod는 논리적인 호스트 또는 노드에서 실행되며, 컨테이너, 저장소, 네트워크 리소스 등을 공유할 수 있습니다.\n각각의 Pod는 고유한 IP 주소를 가지며, 포트 공간을 공유하여 서로 통신할 수 있습니다. Pod는 주로 관련된 서비스를 함께 실행하기 위해 사용되며, 서비스 디스커버리, 로깅, 모니터링 등을 위한 사이드카 컨테이너를 함께 포함할 수도 있습니다.\nPod는 일시적인 존재이며, 언제든지 새로운 Pod로 교체될 수 있으며, 이는 확장성과 견고성을 높이기 위한 K8s의 핵심 개념 중 하나입니다.\n노드(Node)는 K8s 클러스터의 물리적 또는 가상의 서버입니다. 노드는 Pod를 실행하는 호스트로 사용되며, 컨테이너 런타임(예: Docker)과 K8s 에이전트가 설치되어 있습니다. 각 노드는 일련의 리소스(CPU, 메모리, 디스크 등)를 제공하고, Pod를 스케줄링하여 실행합니다. 여러 개의 Pod는 여러 노드에 분산되어 실행될 수 있습니다.\n","permalink":"https://haservi.github.io/posts/review/udemy-k8s-docker/","summary":"Udemy 강의중 Docker \u0026amp; Kubernetes 강의를 수강 후 내용 정리 및 리뷰를 작성합니다.\n우선 Udemy는 외국 강의가 많고, 한달에 여러번 할인을 하기에 괜찮은 강의가 있으면 미리 결재해 놓는게 좋습니다.\n강의 후기 Udemy 강의는 할인 가격이 저렴해서 그런지 외국 강의라 그런지 수강률이 높지 않은데 해당 강의는 제가 Udemy에서 수강했었던 강의 중 만족도는 상위권이라 생각합니다.\n주로 Backend 개발자 입장에서 해당 강의로 얻을 수 있는 점은 Docker와 Docker-compose를 이용해 개발 생산성을 높일 수 있다 생각합니다.","title":"Udemy K8s Docker 강의 후기 및 정리"},{"content":"6개월 프로젝트로 Node.js를 처음 하면서 만났던 여러 문제들을 처리한 내용을 공유합니다.\n약 4개월 정도는 backend 개발을 했던 것 같고, 이후 다른 시스템과 함께 맞춰서 프로젝트를 마무리 했던 것 같습니다.\nbackend에서는 기본적인 CRUD 기능과 유효성 처리, jwt 인증, 파일 업로드(이어올리기, siging작업 등), FOTA 캠페인 진행 등이 주요 내용입니다.\n프로젝트 기술 선택 Framework: express DB: MySQL 먼저 Node.js에서 유명한 프레임워크로 express와 nest.js가 있습니다.\n먼저 Spring Backend에 대한 경험으로 nest.js에 대해 고민했지만, npm trends 비교 및 express가 개발 속도 및 현재까지 사용한 사용자도 많기에 express로 선택했습니다.\nORM은 어느 정도의 진입장벽이 있다고 판단하여 typeorm의 기본적인 쿼리로 정도만 넣었으며, native query를 이용하여 동작하도록 설정 후 이후 리팩토링을 했습니다.\n개발 돌이켜보면 처음 한달에 삽질을 많이하고 그 뒤로는 어느 정도 프로젝트의 구조가 잡히니 기능 구현에 큰 어려움은 없었습니다.\n이후 다른 시스템 지원이 어려웠던 것 같았습니다. c, c++ 프로젝트 ㅠ..\n1월 1주차\nexpress 프로젝트 생성을 합니다. 음?? 그런데 기존에 찾아봤던 Node.js의 구조와 다르더군요. 무슨 bin폴더에서 www파일을 이용해서 빌드가 되는데 좀 마음에 안든다. VS Code에서 디버깅은 어떻게 해야하지?\n1월 2주차\njavascript는 대충 알겠다. 타입이 없어서 좀 마음에 안들지만 디버깅 주도 개발 하면 금방 개발이 되니 좋은것도 같다. Type ORM과 MySQL을 함께 쓸 때 native 쿼리를 쓸 경우는 어떻게 설정하고 release()는 꼭 해줘야 하네. 기본적인 CRUD는 어느 정도 처리할 수 있겠다.\n1월 3주차\nJavascript에서 Typescript로 코드를 변경했다. tsconfig를 통해 Typescript를 쓸 수 있나 보다. enum을 지양하네? 이유가 뭘까? 관련 링크 이 시기부터 이펙티브 타입스크립트 책을 함께 읽었습니다. any 타입에 대한 이해 및 MVC 스타일로 작성할 때 DTO와 Entity에 대한 처리 방법(class-transformer) 반복적인 API 생성 및 유효성 처리 작업 PM2 및 DB 커넥션 이슈 등을 만나게 됨 대용량 파일 처리 시 동작 방식에 대한 이해(비동기로 많이 쪼개서 작업하는게 빠르다?) busboy 라이브러리의 close와 finish를 같이 쓰면 linux에서 빌드 시 오류가 발생할 수 있다. req.end 관련 문제 같음 프로젝트 진행하면 만난 문제점들 express와 nest.js 중 어떤게 프로젝트에 좋을지\n기간이 짧은 경우 express를 사용하는게 좋지만, 유지보수 측면에서는 nest.js가 더 좋을 것도 같다. 해당 프레임워크 선택은 프로젝트 규모와 기능에 대한 검토가 필요함(빠르게 개발은 express가 좋다고 느낌) 프로젝트 구조는 어떻게 설계하는게 좋을지\n초반에 express-generator를 이용하여 프로젝트 생성(www폴더가 처음엔 뭔지 몰랐는데 이후엔 좀 거부감..) 자바스크립트를 이용해 기능별로 패키지 분리 이후 타입스크립트로 변경하여 전체 구조 변경(기본적인 nodejs backend 처럼 변경) router와 비슷한 개념을 controller로 파일명 변경(controller에서는 request 유효성 처리 및 response 템플릿 처리) service에서 여러 repository와 연동 및 비즈니스로직 데이터 가공(서비스 로직에 비즈니스로직이 들어가면 테스트코드 작성이 어렵다.) repository에서 orm 쿼리 또는 native쿼리로 service처리 DB연동 및 typeorm 적용 여부\nexpress는 mongusdb와 궁합이 좋다고 하지만 현재 프로젝트 기간 및 no-sql보다는 mysql를 선택 typeorm entity와 관련하여 synchronize 기능 제공(스프링은 ddl-auto 같다) 스프링 처럼 repository 로 orm 스럽게도 구현이 가능하지만 일정 및 n+1 및 fetch? 이슈 등이 있을 거라 생각하여 일단 간단한 쿼리는 orm 복잡한 쿼리는 native로 처리 후 orm 스럽게 리팩토링 진행 예정 타입스크립트에서 오버로딩은 안되는건가?\n타입스크립트에서는 타입과 런타임의 동작이 무관하기 때문에, 함수 오버로딩은 불가 swagger 문서화 처리\nexpress로 사용하는 경우 swagger에 관련된 코드를 그냥 다른 파일로 빼는게 가독성 측면에서 좋아보임 초반에 거부감이 많이 많이 들었지만, 좀 하다 보면 그래도 할만한 느낌 nest.js를 쓰면 코드 어노테이션으로 처리 가능 코드 실행 중 잘못된 호출 또는 로직 수행중에 exception 발생하면 서버가 죽음\n추후 PM2로 여러 스레드 작업 및 docker로 분리함 typeorm 사용 방법 및 nativequery와 함께 사용하는 방법\n타입스크립트 적용 방법\nC++ 소스코드를 typescript에 선언하고 사용하는 방법\nnode-addon 대용량 파일을 업로드하고 다운로드 하는 방법 및 문제점\n파일 업로드 시 busboy를 이용해 chunk값으로 이어올리기 기능 구현 request에 대한 유효성 체크 방법\nnpm 중 class-validation과 express-validation이 있다. class-valdaion의 경우 request dto에 어노테이션 을 선언해서 사용하고, express-validation은 라우터에서 처리한다. npm trends를 보면 class-validation을 더 많이 사용함 response 응답값에 대한 template 생성 및 유효성 처리를 공통적으로 하는 방법\n유효성이 실패한 경우 다양한 형태가 존재하며, 이것에 대한 함수를 나눠 처리함 async await의 올바른 사용법과 트랜잭션 처리\n쿼리 또는 함수의 응답값이 필요한 경우 await를 이용해 처리함 미들웨어와 유틸함수의 차이점\n추후 배포할 때 어떻게 하는게 좋을지 고민 필요\n대용량 파일 업로드(10GB 이상) 시 해당 파일 암호화 hash 방법 고민 필요\nfs.createReadStream을 이용하여 처리\ncreateFileSync의 경우 아래와 같은 에러 발생\n1 2 3 4 5 error: [package/file-upload: File size (12884910080) is greater than 2 GB {\u0026#34;code\u0026#34;:\u0026#34;ERR_FS_FILE_TOO_LARGE\u0026#34;,\u0026#34;stack\u0026#34;:\u0026#34;RangeError [ERR_FS_FILE_TOO_LARGE]: File size (12884910080) is greater than 2 GB\\n at new NodeError (node:internal/errors:372:5)\\n at tryCreateBuffer (node:fs:420:13)\\n at Object.readFileSync (node:fs:465:14)\\n at PackageService... 파일 업로드 이후 메타데이터를 추가해야하는데 어떻게 해야 할지 고민 필요\n요청에 따라 KISA SHA 256을 적용(Javascript 예제가 없어서 Java 또는 C++을 이용예정), 다른 암호화 라이브러리로 해도 될 것 같은데 확인 필요 cryto를 이용해서 hash처리(signing과 관련된 내용 확인 필요) createReadStream이 비동기이기 때문에 이를 위해 new Promise로 적용 파일 업로드와 동시에 hash 처리 하는 방법도 고민 필요(이러면 중간에 끊기면 hash를 어떻게 처리할지 고민 필요) Typescript에서 문자열 바이트코드 변환 확인\nTextEncoder() 함수 사용 any 타입에 대해서\nany 타입을 사용하면 타입 체커와 타입스크립트 언어 서비스를 무력화시킨다. any 타입은 진짜 문제점을 감추며, 개발 경험을 나쁘게 하며, 코드의 신뢰도를 떨어뜨린다. Worker Thread\n기존 프로젝트에서 C++ 로 처리해야 하는 로직이 있어 addon된 함수를 worker thread 방식으로 적용 Node는 요청을 받으면 현재 요청에 대한 다른 요청을 받을 수 없다. 이러한 처리를 효율적으로 하기 위해 Node는 이벤트 루프와 콜백 함수를 통해 비동기로 동작한다. console.log는 메인쓰레드에서 동작하므로 얘로 테스트 하면 안됨 파일 대용량 db업로드시\nbody Parser = 기본 허용치 100kb 이거를 늘려주면 된다.\n1 2 app.use(express.json({ limit: \u0026#39;50mb\u0026#39; })); app.use(express.urlencoded({ limit: \u0026#39;50mb\u0026#39;, extended: true })); 쿼리 동작중에 Cannot enqueue Query after fatal error.이런 에러가 발생\ndb의 시간 만료를 늘려주면 해결된다는 경우도 있습니다.링크 위와 같이 늘려줬었는데 종종 발생하여 반대로 시간 만료를 극단적으로 줄여서 에러를 확인할 수 있었습니다. 문제는 typeorm과 nativequery를 쓰기위해 repository 파일을 참조하는게 문제의 원인이었습니다. 조금 더 고민해야 할 것 대용량 파일 다운로드 시 효율적인 방법 header의 값에 Range를 할당하여 클라이언트에서 여러 호출을 하도록 지정할 수 있음참고 ","permalink":"https://haservi.github.io/posts/nodejs/start-nodejs/","summary":"6개월 프로젝트로 Node.js를 처음 하면서 만났던 여러 문제들을 처리한 내용을 공유합니다.\n약 4개월 정도는 backend 개발을 했던 것 같고, 이후 다른 시스템과 함께 맞춰서 프로젝트를 마무리 했던 것 같습니다.\nbackend에서는 기본적인 CRUD 기능과 유효성 처리, jwt 인증, 파일 업로드(이어올리기, siging작업 등), FOTA 캠페인 진행 등이 주요 내용입니다.\n프로젝트 기술 선택 Framework: express DB: MySQL 먼저 Node.js에서 유명한 프레임워크로 express와 nest.js가 있습니다.\n먼저 Spring Backend에 대한 경험으로 nest.js에 대해 고민했지만, npm trends 비교 및 express가 개발 속도 및 현재까지 사용한 사용자도 많기에 express로 선택했습니다.","title":"Nodejs 프로젝트 적응기"},{"content":"WSL에서 대용량 파일 처리(한사이클에 50GB..)를 하면서 안그래도 부족한 C드라이브 용량이 바닥이 났습니다.. ㅠㅠ..\nC드라이브를 늘릴 수는 없으니 급한대로 D드라이브 1TB로 변경 후 WSL Ubuntu를 D드라이브로 옮기기로 정했습니다.\nWLS에 대한 명령어는 wsl -h로 확인할 수 있습니다.\n아래의 사진처럼 wsl name을 확인 후 해당 name으로 우선 ubuntu를 정지합니다.\n1 2 wsl -l -v wsl -t [Name] # 특정 WSL 정지 제 경우는 Ubuntu-20.04 라는 Name이므로 해당 이름을 기준으로 커맨드를 작성했습니다.\nWSL 내보내기\n1 wsl --export Ubuntu-20.04 D:\\WSL\\ubuntu20.04\\ubuntu-20-04.tar 기존 WSL 리눅스 제거하기\n아래와 같이 명령어를 입력합니다.\n1 wsl --unregister Ubuntu-20.04 export한 tar파일 import\n2단계에서 내보냈던 압축파일을 import 합니다.\nwsl \u0026ndash;import [서비스명] [설치경로] [내보낸 파일 경로]\n1 wsl --import Ubuntu-18 D:\\WSL\\ubuntu18.04\\ D:\\WSL\\ubuntu18.04\\ubuntu-18-04.tar 사용자 기본 위치 설정\n위의 사진 처럼 리눅스 실행 시 기본 사용자를 지정하려면 아래와 같이 설정하시면 됩니다.\nwsl conf 파일 생성\n1 touch /etc/wsl.conf 기본 사용자 등록\n1 vim /etc/wsl.conf 파일 수정\n1 2 [user] default=home폴더안의사용자이름 이렇게 설정 기존에 내보내기로 만들었던 tar파일은 삭제하셔도 됩니다.\n급한대로 용량에 대한 압박이 조금은 해소됐네요. :D..\n참고 [Windows] WSL 리눅스 설치 경로 변경 ","permalink":"https://haservi.github.io/posts/tips/window-wsl-drive-change/","summary":"WSL에서 대용량 파일 처리(한사이클에 50GB..)를 하면서 안그래도 부족한 C드라이브 용량이 바닥이 났습니다.. ㅠㅠ..\nC드라이브를 늘릴 수는 없으니 급한대로 D드라이브 1TB로 변경 후 WSL Ubuntu를 D드라이브로 옮기기로 정했습니다.\nWLS에 대한 명령어는 wsl -h로 확인할 수 있습니다.\n아래의 사진처럼 wsl name을 확인 후 해당 name으로 우선 ubuntu를 정지합니다.\n1 2 wsl -l -v wsl -t [Name] # 특정 WSL 정지 제 경우는 Ubuntu-20.04 라는 Name이므로 해당 이름을 기준으로 커맨드를 작성했습니다.\nWSL 내보내기","title":"윈도우 WSL Ubuntu D Drive로 변경"},{"content":"netstat을 사용하기 위해서 우선 net-tools를 설치해야합니다.\n1 sudo apt install net-tools 설치 후 netstat -tulpn 를 입력하면 현재 열린 네트워크 포트와 해당 포트를 열어놓은 프로세스를 보여주는 도구입니다.\n여기서 각 옵션의 의미는 다음과 같습니다.\n-t: TCP 프로토콜 사용 포트 -u: UDP 프로토콜 사용 포트 -l: 포트를 열어놓은 프로세스 출력 -p: 프로세스 ID 출력 -n: 포트와 프로세스를 숫자로 출력 따라서 netstat -tulpn 명령어를 실행하면, 현재 열린 TCP/UDP 포트와 해당 포트를 열어놓은 프로세스의 정보를 확인할 수 있습니다.\n다른 방법으로는 ps -ef|grep [프로그램이름]으로도 찾을 수 있습니다.\n이 후 해당 PID를 제거 하고 싶은 경우 아래와 같이 kill [PID]를 입력하면 됩니다.\n","permalink":"https://haservi.github.io/posts/tips/ubuntu-port-kill/","summary":"netstat을 사용하기 위해서 우선 net-tools를 설치해야합니다.\n1 sudo apt install net-tools 설치 후 netstat -tulpn 를 입력하면 현재 열린 네트워크 포트와 해당 포트를 열어놓은 프로세스를 보여주는 도구입니다.\n여기서 각 옵션의 의미는 다음과 같습니다.\n-t: TCP 프로토콜 사용 포트 -u: UDP 프로토콜 사용 포트 -l: 포트를 열어놓은 프로세스 출력 -p: 프로세스 ID 출력 -n: 포트와 프로세스를 숫자로 출력 따라서 netstat -tulpn 명령어를 실행하면, 현재 열린 TCP/UDP 포트와 해당 포트를 열어놓은 프로세스의 정보를 확인할 수 있습니다.","title":"리눅스에서 활성화된 process 종료 방법"},{"content":"WSL 환경에서 DB 설정 방법에 대해 정리했습니다.\n우선 기본적으로 윈도우 환경이며, WSL을 이용해 우분투 18.04 버전을 설치합니다.\nmariadb-server 설치 및 실행 패키지를 최신으로 업데이트 합니다.\n1 2 sudo apt-get update sudo apt-get upgrade 우선 mariadb-server를 설치합니다.\n1 2 3 sudo apt install mariadb-server sudo mysql -u root -p # 실행 DB 저장소 경로 변경 방법 만약 db의 저장소를 변경하고 싶다면 아래와 같이 진행하면 됩니다.\n우선 db의 경로를 /home/data/mysql으로 가정하겠습니다.\ndb 접속 후 현재 db의 경로를 확인합니다.\n1 SELECT @@ datadir; db 정지\n1 sudo service mysql stop 저장소 위치 변경\n1 2 sudo mkdir -p /home/data/ # 폴더 생성 sudo rsync -av /var/lib/mysql /home/data/ # 기존 db 정보 복사 동기화 db 권한 부여 설정\n1 sudo chown -R mysql:mysql /home/data/mysql db 경로 변경\n아래와 같이 명령어로 진입 후 사진처럼 경로를 변경합니다.\n1 sudo vim /etc/mysql/mariadb.conf.d/50-server.cnf home 보안 해제\n아래의 경로에서 사진과 같이 설정합니다.\n1 sudo vim /lib/systemd/system/mariadb.service WSL에 활성화 돼 있는 DB 로컬에서 접속 방법 WSL에 있는 DB를 Heidi SQL 툴 등을 이용해 접속하려면 아래와 같이 설정하면 됩니다.\n외부 포트 접속 허용\n아래 경로의 mariadb 설정 파일의 포트를 0.0.0.0 으로 변경합니다.\n1 sudo vi /etc/mysql/mariadb.conf.d/50-server.cnf mysql restart\n1 sudo service mysql restart 외부 접속 포트 확인 후 접속\nWSL 환경에서 ip addr명령어를 입력하면 172...* 로 시작하는 포트가 있습니다. 해당 포트를\n로컬에서 접속하면 됩니다.\n만약 계정 권한이 없다면 권장되지는 않지만 아래와 같이 특정 계정에 모든 권한을 부여해 접속할 수 있습니다.\n아래와 같은 경우는 user라는 아이디와 0000패스워드로 권한을 부여했습니다.\n1 2 CREATE USER \u0026#39;user\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED BY \u0026#39;0000\u0026#39;; GRANT ALL PRIVILEGES ON *.* TO \u0026#39;user\u0026#39;@\u0026#39;%\u0026#39; WITH GRANT OPTION; 1 2 3 sudo vim /etc/mysql/mariadb.conf.d/50-server.cnf sudo systemctl restart mysql # 이게 안되면 sudo service mysql restart WSL Maria DB 삭제 방법 mariadb server가 설치 중 잘못돼서 엉키면 아래와 같이 삭제할 수 있습니다.\n설정파일도 모두 삭제하기 위해 purge 사용 후 Remove all MariaDB databases? 문구 나오면 예를 눌러주시면 됩니다.\n1 sudo apt-get purge mariadb-* 남아있는 의존성 패키지 제거\n1 sudo apt autoremove mysql 관련 패키지 설치 확인\n1 dpkg -l | grep mysql 제 경우 위와 같이 mysql-common이 설치돼 있어 제거했습니다.\n데이터베이스 파일도 함께 삭제하고 싶다면, 다음 명령어를 입력하세요. 1 2 3 4 sudo rm -rf /var/lib/mysql sudo rm -rf /etc/mysql sudo rm -rf /var/log/mysql.* sudo rm -rf /var/log/mysql 위 명령어를 실행하면 /var/lib/mysql 디렉토리와 하위 파일들이 모두 삭제됩니다. 이 디렉토리는 mariadb-server의 데이터베이스 파일이 저장되는 디렉토리입니다.\n위와 같이 명령어를 실행하시면 mariadb-server를 삭제할 수 있습니다. 다만, 데이터베이스 파일까지 모두 삭제하시면 해당 데이터베이스 파일에 저장된 모든 데이터가 삭제되므로, 주의하시기 바랍니다.\n경고\nERROR 2002 (HY000): Can\u0026rsquo;t connect to local MySQL server through socket \u0026lsquo;/var/run/mysqld/mysqld.sock\u0026rsquo; (2 \u0026ldquo;No such file or directory\u0026rdquo;)\n만약 위와 같은 에러가 발생하면 아래와 같이 db를 재시작해주시면 됩니다.\n1 sudo service mysql restart ","permalink":"https://haservi.github.io/posts/devops/wsl/mariadb-setting/","summary":"WSL 환경에서 DB 설정 방법에 대해 정리했습니다.\n우선 기본적으로 윈도우 환경이며, WSL을 이용해 우분투 18.04 버전을 설치합니다.\nmariadb-server 설치 및 실행 패키지를 최신으로 업데이트 합니다.\n1 2 sudo apt-get update sudo apt-get upgrade 우선 mariadb-server를 설치합니다.\n1 2 3 sudo apt install mariadb-server sudo mysql -u root -p # 실행 DB 저장소 경로 변경 방법 만약 db의 저장소를 변경하고 싶다면 아래와 같이 진행하면 됩니다.\n우선 db의 경로를 /home/data/mysql으로 가정하겠습니다.\ndb 접속 후 현재 db의 경로를 확인합니다.","title":"WSL 환경에서 내부 MariaDB 설치하기"},{"content":"Gerrit은 오픈 소스 웹 기반 코드 리뷰 도구로, Git 버전 관리 시스템을 사용하는 프로젝트에서 코드 검토 및 협업을 용이하게 해줍니다. Gerrit은 구글에서 개발되었으며, 안드로이드 오픈 소스 프로젝트(AOSP) 등 여러 대규모 프로젝트에서 사용되고 있습니다.\nGerrit을 사용하려면 Gerrit 서버를 설치하고 구성해야 합니다.\n설치 방법은 공식 문서에서 확인할 수 있습니다.\nGerrit은 웹 기반 코드 커밋 및 버전 관리 도구로, 코드 리뷰를 위한 기능을 제공합니다.\n개발자들은 Gerrit을 이용하여 Git 저장소에서 작업한 코드 변경 사항을 리뷰하고, 변경을 승인하거나 거부하고, 수정 요청을 할 수 있습니다.\n아래는 Gerrit에서 지원하는 기능에 대한 정보입니다.\n코드 리뷰: Gerrit은 팀원들이 코드 변경을 검토하고 피드백을 제공할 수 있는 기능을 제공합니다. 리뷰어들은 변경 사항을 확인하고, 의견을 남기거나 수정 요청을 할 수 있습니다. 리뷰 프로세스가 완료되면 리뷰어는 변경 사항을 승인하거나 거부할 수 있습니다.\n패치 세트: Gerrit은 패치 세트라는 개념을 도입하여, 동일한 변경 사항에 대한 여러 버전을 추적할 수 있습니다. 이를 통해 개발자는 피드백을 반영하여 변경 사항을 업데이트하고, 리뷰어가 새로운 패치 세트를 쉽게 검토할 수 있습니다.\n브랜치 관리: Gerrit은 Git의 브랜치 관리 기능과 연동되어, 변경 사항이 리뷰를 통과하면 자동으로 브랜치에 병합됩니다. 이를 통해 코드베이스의 안정성이 유지되며, 팀원들이 협업을 효율적으로 진행할 수 있습니다.\n통합 지원: Gerrit은 다양한 지속적 통합(CI) 도구와 통합할 수 있어, 코드 변경이 병합되기 전에 테스트 및 빌드가 정상적으로 수행되는지 확인할 수 있습니다.\n접근 제어: Gerrit은 사용자 권한을 세분화하여, 프로젝트의 각 부분에 대한 접근 권한을 조절할 수 있습니다. 이를 통해 개발자와 리뷰어가 적절한 권한을 가지고 작업을 진행할 수 있습니다.\nGerrit은 안정적인 코드 리뷰를 보장하며 Git의 다양한 기능과 함께 사용할 수 있습니다.\nGerrit을 통해 코드 리뷰 문화가 제대로 돼 있다면 서로에게 좋은 효과를 줄 것이라 생각합니다.\n혼자 진행하는 프로젝트의 경우, Gerrit과 같은 코드 리뷰 도구의 이점은 크지 않습니다.\n개인 프로젝트에서는 Git의 기본 기능만으로도 충분히 버전 관리와 코드 추적을 할 수 있습니다. 예를 들어, 브랜치를 생성하여 새로운 기능을 개발하고, 완료되면 메인 브랜치에 병합하는 방식으로 작업할 수 있습니다.\n추가 에러 처리 관련 Gerrit을 사용할 때는 반드시 코드 리뷰를 거쳐야만 코드를 변경할 수 있습니다. 먼저 ssh 설정을 완료한 후, commit을 하고 명령어를 입력할 때 change-id가 없으면 에러가 발생할 수 있으니 주의해야 합니다.\n1 git push origin HEAD:refs/for/master 그러면 아래와 같은 에러가 발생합니다.\n경고\nremote: Resolving deltas: 100% (4 / 4)\nremote: Processing changes: refs: 1, done\nremote: ERROR: commit bd76487: missing Change-Id in message footer\nremote:\nremote: Hint: to automatically insert a Change-Id, install the hook:\nremote: gitdir=$(git rev-parse --git-dir); scp -p -P 29418 ~~~\nremote: and then amend the commit:\nremote: git commit --amend --no-edit\nremote: Finally, push your changes again\nremote:\n위의 힌트 2개를 그대로 넣으면 change-id가 설정됩니다.\n1 2 gitdir=$(git rev-parse --git-dir); scp -p -P 29418 ~~~ git commit --amend --no-edit 이 에러 메시지는 Gerrit을 사용하는 git 서버에서 commit message에 Change-Id가 없기 때문에 발생합니다.\nGerrit에서는 Change-Id를 사용하여 각각의 변경 사항에 고유한 ID를 부여하고 이를 사용하여 여러 작업을 관리합니다.\n해결 방법으로는 아래의 명령어를 통해 Gerrit에서 제공하는 commit-msg hook을 설치하고 commit message를 다시 작성하여 commit을 다시 시도하면 됩니다\n","permalink":"https://haservi.github.io/posts/tips/git-gerrit/","summary":"Gerrit은 오픈 소스 웹 기반 코드 리뷰 도구로, Git 버전 관리 시스템을 사용하는 프로젝트에서 코드 검토 및 협업을 용이하게 해줍니다. Gerrit은 구글에서 개발되었으며, 안드로이드 오픈 소스 프로젝트(AOSP) 등 여러 대규모 프로젝트에서 사용되고 있습니다.\nGerrit을 사용하려면 Gerrit 서버를 설치하고 구성해야 합니다.\n설치 방법은 공식 문서에서 확인할 수 있습니다.\nGerrit은 웹 기반 코드 커밋 및 버전 관리 도구로, 코드 리뷰를 위한 기능을 제공합니다.\n개발자들은 Gerrit을 이용하여 Git 저장소에서 작업한 코드 변경 사항을 리뷰하고, 변경을 승인하거나 거부하고, 수정 요청을 할 수 있습니다.","title":"Gerrit 코드 리뷰에 대해"},{"content":"node.js backend 에서 작업 중 테스트 서버에 배포 스크립트를 작성했습니다.\n위와 같이 $'\\r': coomand not found가 발생하면 해결 방법은 아래와 같습니다.\n1 sed -i \u0026#39;s/\\r$//\u0026#39; [스크립트파일.sh] 문제의 원인은 유닉스 기반의 운영체제에서는 줄 바꿈 문자로 줄 바꿈(Line Feed, LF)을 사용하지만, 윈도우 운영체제에서는 줄 바꿈 문자로 CR과 LF를 함께 사용합니다.\n그렇기 때문에 유닉스 기반의 운영체제에서는 Windows에서 생성된 텍스트 파일을 처리할 때 이러한 CR 문자가 문제가 될 수 있습니다.\nsed 유틸리티를 사용하여 스크립트 파일에서 Windows에서 생성된 줄 바꿈 문자(Carriage Return, CR)를 제거할 수 있습니다.\n위 명령어에서 사용된 sed 명령어는 s/패턴/치환/ 형식으로, 파일 내에서 패턴을 찾아 해당 패턴을 치환하는 명령어입니다.\n여기서는 파일 내의 모든 CR 문자를 제거하는 명령어입니다.\n","permalink":"https://haservi.github.io/posts/tips/error-script-to-linux/","summary":"node.js backend 에서 작업 중 테스트 서버에 배포 스크립트를 작성했습니다.\n위와 같이 $'\\r': coomand not found가 발생하면 해결 방법은 아래와 같습니다.\n1 sed -i \u0026#39;s/\\r$//\u0026#39; [스크립트파일.sh] 문제의 원인은 유닉스 기반의 운영체제에서는 줄 바꿈 문자로 줄 바꿈(Line Feed, LF)을 사용하지만, 윈도우 운영체제에서는 줄 바꿈 문자로 CR과 LF를 함께 사용합니다.\n그렇기 때문에 유닉스 기반의 운영체제에서는 Windows에서 생성된 텍스트 파일을 처리할 때 이러한 CR 문자가 문제가 될 수 있습니다.\nsed 유틸리티를 사용하여 스크립트 파일에서 Windows에서 생성된 줄 바꿈 문자(Carriage Return, CR)를 제거할 수 있습니다.","title":"Linux에서 배포 스크립트($'/r') 발생 시 처리 방법"},{"content":"인프라 관련 내용 정리가 필요할 것 같아 중요한 키워드 정도로 정리한 내용입니다.\nAWS EC2 접속 명령어 기본적으로 pem키를 발급받고 네트워크 보안이 올바르면 아래와 같은 명령어로 pem키를 이용해 접속 가능합니다.\n1 2 chmod 400 [pem파일명] ssh -i [pem키 파일명] ubuntu@[퍼블릭 IP 주소] 입력했던 콘솔 보기\n1 history bastion host 설정 bastion host란 내부와 외부 네트워크 사이에서 게이트 역할을 수행하는 호스트입니다.\n내부 서버나 중요 리소스를 보호하기 위해 생성되며, 일반 유저들에게는 공개하지 않습니다.\nbastion host에서 공개키를 생성한 후 접속하려는 서비스 서버에 키를 추가하여 접속할 수 있습니다.\n서비스용 서버에 22번 포트로의 접근은 bastion host만 가능하도록 security group을 설정해야합니다.\n1 2 3 4 5 6 # Bastion Server에서 공개키를 생성 bastion $ ssh-keygen -t rsa bastion $ cat ~/.ssh/id_rsa.pub # 접속하려는 서비스용 서버에 키 추가 $ vi ~/.ssh/authorized_keys 위와 같이 설정한 후 해당 서비스용 ip를 별칭으로 입력합니다.\n1 vim /etc/hosts 해당 파일에서 아래와 같이 입력하면 됩니다.\n1 [ip주소] [별칭] 사용할 때는 아래와 같이 쓰면 됩니다.\n1 ssh [별칭] latency 인증 관련 도메인 생성 사이트에서 도메인을 발급받은 뒤 docker의 certbot을 통해 SSL 인증서를 무료로 발급받을 수 있습니다.\n1 2 3 4 docker run -it --rm --name certbot \\ -v \u0026#39;/etc/letsencrypt:/etc/letsencrypt\u0026#39; \\ -v \u0026#39;/var/lib/letsencrypt:/var/lib/letsencrypt\u0026#39; \\ certbot/certbot certonly -d \u0026#39;[도메인 주소]\u0026#39; --manual --preferred-challenges dns --server https://acme-v02.api.letsencrypt.org/directory 발급받은 뒤 도메인 사이트에 아래와 같이 TXT(SPF)를 추가 해줘야합니다.\n1 2 3 # 인증서 경로 /etc/letsencrypt/live/[도메인주소]/fullchain.pem ./ /etc/letsencrypt/live/[도메인주소]/privkey.pem ./ 이후 nginx나 tomcat에 해당 인증서 키를 추가해야합니다.\ngit submodule 관련 키, 계정 정보, DB IP주소 패스워드 등 공개하고 싶지 않은 정보는 git private 저장소에 저장하고 해당 레포지토리를 submodule로 이용할 수 있습니다.\n1 git submodule add [자신의 private 저장소] ./src/main/resources/config 이후 source code 받을때\n1 2 3 4 5 6 git clone --recurse-submodules [자신의 프로젝트 저장소] # 설정 파일이 변경된 경우 git submodule foreach git pull origin main # 위의 설정이 안되면 아래로..! git submodule update --init --recursive k6 부하테스트 관련 k6는 부하테스트를 위한 라이브러리입니다. apache의 ab나 naver의 nGrinder처럼 부하테스트를 할 수 있는 도구입니다.\n설치 후 실행은 아래처럼 사용하면 됩니다.\n1 k6 run [파일명.js] k6를 gui로 보기 좋게 해주는 grafana도 있습니다.\njar 스크립트 배포 관련 스크립트를 이용해서 배포를 할 수 있습니다. 아래의 코드는 Spring 프로젝트를 정지, 빌드, 배포하는 스크립트 입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 PROJECT_PATH=\u0026#39;프로젝트 경로\u0026#39; JAR_PATH=${PROJECT_PATH}/build/libs JAR=$(cd ${JAR_PATH} \u0026amp;\u0026amp; find ./* -name \u0026#34;*jar\u0026#34; | cut -c 3-) JAR_PID=$(ps -ef | grep $JAR | grep -v grep | awk \u0026#39;{print $2}\u0026#39;) function stop_process() { if [ -z \u0026#34;$JAR_PID\u0026#34; ]; then echo \u0026#34;프로세스가 실행중이지 않습니다.\u0026#34; else echo \u0026#34;$JAR의 프로세스를 종료합니다. (PID = $JAR_PID)\u0026#34; kill $JAR_PID fi } function build() { cd ${PROJECT_PATH} \u0026amp;\u0026amp; ./gradlew clean build } function start_process() { java -jar -Dspring.profiles.active=prod $JAR_PATH/$JAR } echo -e \u0026#34;${txtylw}=======================================${txtrst}\u0026#34; echo -e \u0026#34;${txtgrn} Deploy Start ${txtrst}\u0026#34; echo -e \u0026#34;${txtylw}=======================================${txtrst}\u0026#34; stop_process build start_process 위의 파일은 [파일명].sh로 확장자를 구성해야 하며, 처음에 권한을 추가해준뒤 아래 명령어로 실행하면 됩니다.\n1 2 3 4 # 권한 추가 chmod +x [파일명.sh] # 실행 ./[파일명.sh] 이외에도 AWS 모니터링, 스케일 아웃, AWS Launch Template 등 인프라 설정을 한다면 조금 더 안정적으로 웹 서비스를 운용할 수 있습니다.\n","permalink":"https://haservi.github.io/posts/devops/aws/infra-tips/","summary":"인프라 관련 내용 정리가 필요할 것 같아 중요한 키워드 정도로 정리한 내용입니다.\nAWS EC2 접속 명령어 기본적으로 pem키를 발급받고 네트워크 보안이 올바르면 아래와 같은 명령어로 pem키를 이용해 접속 가능합니다.\n1 2 chmod 400 [pem파일명] ssh -i [pem키 파일명] ubuntu@[퍼블릭 IP 주소] 입력했던 콘솔 보기\n1 history bastion host 설정 bastion host란 내부와 외부 네트워크 사이에서 게이트 역할을 수행하는 호스트입니다.\n내부 서버나 중요 리소스를 보호하기 위해 생성되며, 일반 유저들에게는 공개하지 않습니다.","title":"Infra 설정 관련 정리"},{"content":"종종 프로젝트 중에는 특정 Node.js 버전에서만 동작하는 프로젝트가 있습니다. 이럴 경우 Docker를 이용하여 컨테이너를 만들거나 로컬인 경우 해당 버전에 맞는 Node.js를 설치해야 합니다.\n이번 내용은 전에 작성한 jdk 버전을 변경하듯이 Node.js 버전을 변경하는 방법에 대해 알아볼께요. 알림\n해당 글은 Window를 기준으로 작성했습니다.\nMac의 경우는 해당 stackoverflow 질문글을 참조해주세요.\n먼저 해당 링크에서 우측의 Release 버튼을 선택합니다. nvm-setup.exe 파일을 다운로드 받습니다. 아래와 같이 파일을 설치하고 버전을 커맨드로 입력해보면 설치된 것을 확인할 수 있습니다. 정상적으로 설치 됐는지 확인하기 위해서는 nvm version의 명령어를 cmd에 입력하면됩니다.\n특정 Node.js를 설치할 때는 nvm install \u0026lt;version\u0026gt; 을 입력하면 됩니다.\nNode.js 버전은 해당 링크 에서 확인할 수 있습니다.\n경고\n주의할 점은 버전을 변경할 경우 cmd창을 관리자 모드로 실행해야합니다.\n관리자 모드에서 다운로드 받은 Node.js 버전을 nvm use \u0026lt;version\u0026gt; 으로 입력하면 변경됩니다.\nnvm list 를 입력하면 현재 설치된 Node.js 버전을 확인할 수 있습니다.\n","permalink":"https://haservi.github.io/posts/tips/window-nodejs-version-change/","summary":"종종 프로젝트 중에는 특정 Node.js 버전에서만 동작하는 프로젝트가 있습니다. 이럴 경우 Docker를 이용하여 컨테이너를 만들거나 로컬인 경우 해당 버전에 맞는 Node.js를 설치해야 합니다.\n이번 내용은 전에 작성한 jdk 버전을 변경하듯이 Node.js 버전을 변경하는 방법에 대해 알아볼께요. 알림\n해당 글은 Window를 기준으로 작성했습니다.\nMac의 경우는 해당 stackoverflow 질문글을 참조해주세요.\n먼저 해당 링크에서 우측의 Release 버튼을 선택합니다. nvm-setup.exe 파일을 다운로드 받습니다. 아래와 같이 파일을 설치하고 버전을 커맨드로 입력해보면 설치된 것을 확인할 수 있습니다.","title":"Windows Node.js 버전 변경하기"},{"content":"Window에서 JDK 버전 간편하게 변경하기 Java를 사용하여 프로젝트를 진행하다 보면 우선적으로 OS 명령을 내리기 위한 JDK(Java Develop Kit) 설치가 필요합니다.\n그렇지만 특정 Java 버전을 필요로 하는 프로젝트도 있습니다.\n이를 해결하기 위해 도커로 환경을 구성하거나 해당 로컬 컴퓨터의 환경변수를 설정하여 변경하는 것도 가능합니다.\n해당 글은 스크립트를 생성하여 터미널 명령어로 간단하게 자바 버전을 변경하는 방법입니다.\n모든 설정이 끝나면 아래처럼 터미널에서 명령어만 입력하면 스크립트를 변경 할 수 있습니다.\nJDK 설치 및 폴더명 변경 우선 JDK를 다운로드 아무래도 라이선스의 문제가 있을 수 있으니 OpenJDK를 다운받는 것을 추천드립니다.\n우선 해당 링크에서 다운 받을 수 있습니다.\n마이크로소프트에서도 openjdk를 다운로드 받을 수 있는 링크를 제공하고 있습니다. 다운로드 받은 폴더명은 아래와 같은 파일명으로 변경해줍니다.\n스크립트에 해당 폴더이름과 동일하게 맞췄기 때문에 변경을 원하시면 스크립트도 함께 변경해줘야 합니다.\n또한, 해당 스크립트 압축파일도 scripts 폴더에 풀어서 넣어줍니다. 해당 스크립트 명령어를 이용하여 터미널에서 자바 버전을 변경하도록 설정할 예정입니다.\n환경 변수 설정 일반적으로 윈도우에서 설정하는 환경변수 설정과 거의 동일합니다.\n약간의 차이점은 터미널에 스크립트 변수를 실행할 수 있는 변수를 지정 하는 정도에요.\n시스템 환경 변수 편집 화면에서 환경변수 를 선택합니다. 윈도우 버튼을 누르고 검색에 환경 변수만 치면 시스템 환경 변수 편집이 나타납니다. 다른 방법으로는 탐색기에서 내 PC 우 클릭 후 속성 -\u0026gt; 오른쪽에 고급 시스템 설정을 선택해주면 됩니다. 환경변수 선택 후 아래쪽의 새로 만들기를 눌러 줍니다.\n두개 시스템 이름은 JAVA_HOME 경로는 자주 사용하는 JDK 버전의 폴더 경로까지면 설정해줍니다. 제 경우는 OpenJDK11 버전을 주로 이용하기 때문에 C:\\Program Files\\Java\\openjdk11로 경로 설정을 했습니다.\n이제 Path에 위의 경로에 /bin를 추가하는 경로와 스크립트 경로를 지정합니다. 시스템 이름에서 Path를 선택 한 후 편집을 선택합니다. 그 후 아래와 같이 경로를 설정합니다. %JAVA_HOME%\\bin의 경우 3번에서 진행한 jdk 경로에 bin폴더 위치를 추가한 것이며, C:\\Program Files\\Java\\scripts는 기존에 추가한 스크립트 변수를 터미널에서 사용하기 위한 경로입니다.\n이렇게 설정해 주신 뒤 터미널을 실행하여 openjdk8, openjdk11, openjdk17을 명령어로 입력하면 자바 버전을 변경할 수 있습니다.\n추가사항 알림\n위의 방법은 현재의 터미널에서 변경되는 방법입니다.\n한번 설정으로 모든 환경에 영향을 받기위해서는 아래와 같이 설정합니다.\n위의 스크립트를 열어보면 아래와 같습니다.\n1 2 3 4 @echo off set JAVA_HOME=C:\\Program Files\\Java\\openjdk17 set Path=%JAVA_HOME%\\bin;%Path% echo Java 17 activated. 해당 스크립트를 전역으로 사용하고 싶다면 아래와 같이 변경하면 됩니다. 명령어는 관리자 모드의 터미널에서 가능합니다.\n1 2 3 @echo off setx JAVA_HOME \u0026#34;C:\\Program Files\\Java\\openjdk17\u0026#34; /m echo Java 17 activated. Path는 제거해주셔야합니다. 함께 사용하는 경우 환경변수에 강제로 추가됩니다.\n참조 링크 Java Custom Setting OpenJDK vs OracleJDK JDK 전역 변수로 설정 관련 ","permalink":"https://haservi.github.io/posts/tips/window-java-version-change/","summary":"Window에서 JDK 버전 간편하게 변경하기 Java를 사용하여 프로젝트를 진행하다 보면 우선적으로 OS 명령을 내리기 위한 JDK(Java Develop Kit) 설치가 필요합니다.\n그렇지만 특정 Java 버전을 필요로 하는 프로젝트도 있습니다.\n이를 해결하기 위해 도커로 환경을 구성하거나 해당 로컬 컴퓨터의 환경변수를 설정하여 변경하는 것도 가능합니다.\n해당 글은 스크립트를 생성하여 터미널 명령어로 간단하게 자바 버전을 변경하는 방법입니다.\n모든 설정이 끝나면 아래처럼 터미널에서 명령어만 입력하면 스크립트를 변경 할 수 있습니다.\nJDK 설치 및 폴더명 변경 우선 JDK를 다운로드 아무래도 라이선스의 문제가 있을 수 있으니 OpenJDK를 다운받는 것을 추천드립니다.","title":"OpenJDK 버전 간편하게 변경하기"},{"content":"시작하며 DSM 7버전에서는 SVN과 GitLab을 패키지로 지원하지 않습니다.\n그렇기 때문에 Docker를 이용하여 설치해야 합니다.\n제 경우는 KT 공유기와 Synology NAS(220+)에 램 8기가를 추가한 상태입니다.\n공유기 포트포워딩만 조금 다를 뿐 전체적인 방법은 동일할 것이라 생각됩니다.\nGitLab을 쾌적하게 쓰시려면 최소 램 4기가 이상으로 설정하시는게 좋습니다. 해당 설정은 컨테이너 생성 후에도 편집이 가능하니 필요에 따라 조정하시면 됩니다.\n알림\n완성 후 GitLab Repository 주소 경로가 올바르지 않은 이슈가 있지만 아래와 같이 설정하면 사용하는데 이상은 없을 것이라 생각됩니다.\nDocker에 GitLab 설치 패키지 센터에서 도커 설치 먼저 패키지 센터에서 Docker를 설치합니다. 도커를 실행 후 레지스트리에서 gitlab 검색 후 gitlab/gitlab-ce를 설치합니다. 조금 시간이 지난 후 설치가 완료되면 해당 이미지를 실행합니다. 도커 이미지 실행 및 설정하기 도커를 이미지를 실행 하면 다음과 같이 설정을 진행해야 합니다.\n먼저 고급 설정에서 자동 재시작 활성화를 합니다. 이렇게 되면 NAS가 죽었다 살아나도 알아서 실행됩니다. 포트 설정을 해줍니다. 로컬 포트는 임의로 해도 되지만 컨테이너 포트는 꼭 맞춰주셔야 합니다. 그리고 도커의 볼륨을 추가합니다. 공식홈페이지처럼 컨테이너 볼륨에 저장되는 정보를 NAS 로컬 위치로 매핑 시켜줍니다. 이렇게 설정 후 적용을 하면 컨테이너가 만들어 졌습니다. 해당 컨테이너가 결국은 하나의 GitLab을 구동하기 위한 서버라고 보시면 됩니다. 기본적으로 GitLab의 슈퍼관리자 아이디는 root이며, 패스워드는 방금 설정한 config 폴더의 initial_root_paasword파일에 암호가 있습니다.\n해당 암호를 보기 위해선 패키지 센터에서 텍스트 편집기를 설치하신 후 열어주시면 됩니다.\n패스워드를 확인 후 아래와 같이 컨테이너를 실행해주고 GitLab이 빌드(3~5분 정도)가 되면 접속이 가능합니다. 일단 이렇게 설정하시면 도커를 이용한 GitLab 설치는 정상적으로 끝났습니다.\n만약 해당 컴퓨터에서만 쓰실 경우는 NAS가 연결된 상태에서 해당 LAN IP로 접속해도 이용은 가능합니다.\n그렇지만 NAS를 쓰는 목적이 어디에서든 접속 가능하기 위함이니.. 조금 더 진행해주셔야 합니다.\nHTTP 설정을 하지 않고 바로 HTTPS로 넘어가셔도 무방합니다.\nHTTP 설정 및 공유기 포트포워딩 일단 NAS를 쓰시는 분들은 기본적으로 할당받을 수 있는 QuickConnectId가 있습니다. 해당 도메인 주소를 통해 우리는 외부에서 나의 NAS에 접속할 수 있습니다.\n하지만 보안상 아무나 이러한 접근을 허용하면 안되죠. 그렇기에 NAS의 설정에서 방화벽 규칙을 허용해줘야 하며, 공유기에서도 해당 포트로 접근 시 NAS에서 허용한 포트로 포트포워딩을 해줘야 합니다.\nNAS 방화벽 허용하기 제어판에서 방화벽에 들어간 후 규칙편집을 선택합니다. 방화벽 규칙을 생성합니다. 내장된 응용 프로그램 목록에서 선택에서 선택을 눌러주세요. 방금 전 만든 GitLab 컨테이너 포트를 선택합니다. 활성화 여부를 체크하고 확인을 눌러주세요. 여기까지 진행됐다면 NAS에 공유기를 물려서 사용하시는 분은 해당 공유기에서 NAS DNS로 접속하시면 접속이 되는 것을 확인 할 수 있습니다.\n공유기 포트포워딩 적용 제 경우는 KT 홈 허브 공유기가 있기에 해당 설정에 맞춰서 정리 하겠습니다.\n일단 IpTime과 달리 허브 기기의 관리자 페이지에 접속하기 위해선 공유기 와이파이 망 내 또는 랜선을 통해 웹페이지에서 172.30.1.254 로 접속해야 합니다.\n해당 화면에 처음 접속한 경우 기본 아이디와 패스워드는 아래와 같습니다.\n1 2 3 4 5 6 구형 ID: ktuser PW: megaap 신형 ID: ktuser PW: homehub 로그인 후 패스워드는 변경해주시는게 좋습니다. 추후 비밀번호를 잊어버리면 초기화하면 됩니다.\n먼저 UPnP(Universal Plug and Play) 설정을 해제하겠습니다. UPnP가 있으면 한번 포트 연결이 되면 이후에 포트포워딩을 지워도 적용됩니다. 편리한 기술이지만 보안에 취약한 문제가 있습니다.\n포트 포워딩 설정은 장치설정 -\u0026gt; 트래픽 관리 -\u0026gt; 포트 포워딩 설정으로 접근하면 됩니다.\n여기서 중요한 값은 외부포트, 내부 IP 주소, 내부 포트 입니다. 외부에서 들어오는 포트 주소입니다. 해당 포트로 들어오면 허브가 내부 포트로 포트를 변경해줍니다.\n외부포트는 임의로 정해도 되며, 내부 포트는 처음 Docker 컨테이너 포트에서 선택했던 포트 값을 지정해주면 됩니다.\n내부 IP 주소는 NAS에 연결된 내부 IP 주소를 입력해주면 됩니다.\n이렇게 설정하시면 이제 http는 어디서든 접속이 가능합니다.\nHTTPS 적용 및 역방향 프록시 설정 HTTPS를 적용할 예정이면 위으 포트포워딩에 443 포트만 적용하면 됩니다. NAS에서는 역방향 프록시 설정을 할 수 있습니다.\n그렇기 때문에 기존에 할당 받은 도메인에 여러 서브도메인을 설정할 수 있습니다.\n티스토리로 예를 들면 tistory.com은 하나의 도메인이지만 각각의 사용자는 앞에 user.tistory.com 식으로 자신의 도메인을 할당 받을 수 있는 원리와 비슷하다고 보면 됩니다.\n역방향 프록시 설정 역방향 프록시 설정 화면으로 이동합니다. 역방향 프록시 규칙을 설정합니다. 소스는 외부에서 접근하는 도메인 주소로 보시면 됩니다. 호스트이름 앞에 원하는 서브도메인을 입력하고 해당 도메인주소를 연결합니다. 대상은 기존 도메인주소와 도커 HTTP 컨테이너 포트를 입력합니다. 공유기 포트포워딩을 통해 HTTPS 포트인 443 포트를 허용해줍니다. NAS 인증서 발급 이제 외부에서 접속은 가능합니다. 하지만 HTTPS에서는 해당 도메인주소가 인증된 주소인지 확인하기 위해 인증서 발급이 필요합니다.\n일반적으로는 openssl 또는 사설 인증서를 이용하여 인증서를 발급받아야 하지만 NAS에서는 해당 과정 없이 간편하게 인증서를 발급받을 수 있습니다.\n제어판 -\u0026gt; 보안 -\u0026gt; 인증서로 이동후 추가를 눌러줍니다. 새인증서를 추가합니다. 인증서 이름과 Let\u0026rsquo;s Encrypt에서 인증서 얻기를 선택합니다. 역방향 프록시로 지정한 도메인 주소를 적습니다. 이메일은 본인의 이메일을 선택하시면 됩니다. 인증서 화면에서 설정에 들어가서 해당 인증서를 역방향 프록시에서 지정한 도메인과 매칭시킵니다. 모든 설정이 끝났습니다. 이렇게 하면 외부에서도 HTTPS로 접속이 가능합니다.\n기타 GitLab 프로젝트 생성 시 Clone with SSH와 Clone with HTTP의 주소가 프로젝트 레포지토리 주소와 매칭되지 않은 현상이 있습니다.\nGITLAB_HOST설정도 해보고, external_url도 지정해봤는데 제대로 되지 않아서 임시적으로 Clone with HTTP를 커스텀하는 방법(링크)이 있습니다.\n관리자로 로그인 후 좌측 메뉴에서 Admin을 선택합니다. Setting -\u0026gt; General -\u0026gt; Visibility and access controls 로 이동합니다. 해당 항목 중 Custom Git clone URL for HTTP(S) 의 값을 HTTPS로 인증한 도메인 주소로 추가합니다. ","permalink":"https://haservi.github.io/posts/devops/docker/nas-docker-gitlab-setting/","summary":"시작하며 DSM 7버전에서는 SVN과 GitLab을 패키지로 지원하지 않습니다.\n그렇기 때문에 Docker를 이용하여 설치해야 합니다.\n제 경우는 KT 공유기와 Synology NAS(220+)에 램 8기가를 추가한 상태입니다.\n공유기 포트포워딩만 조금 다를 뿐 전체적인 방법은 동일할 것이라 생각됩니다.\nGitLab을 쾌적하게 쓰시려면 최소 램 4기가 이상으로 설정하시는게 좋습니다. 해당 설정은 컨테이너 생성 후에도 편집이 가능하니 필요에 따라 조정하시면 됩니다.\n알림\n완성 후 GitLab Repository 주소 경로가 올바르지 않은 이슈가 있지만 아래와 같이 설정하면 사용하는데 이상은 없을 것이라 생각됩니다.","title":"Synology NAS로 Docker GitLab 설치하기"},{"content":"인텔리J에서 스프링 프로젝트를 생성하면 아래 셋팅은 미리 설정하면 좋습니다.\n1. 어노테이션 프로세싱 활성화 롬복과 같은 외부 라이브러리를 의존성 주입하게 될 경우 해당 사항을 체크해줘야 컴파일 시 문제 없이 동작합니다.\n설정에서 검색창에 annotation을 입력하면 아래와 같은 화면이 나옵니다.\n2. Build and run IntelliJ IDEA로 변경 IntelliJ IDEA 인텔리제이 자체에서 제공하는 빌드 자동화 도구입니다.\n기본은 Gradle로 설정 돼 있습니다. 이걸 IntelliJ IDEA로 변경하면 더 빠른 테스트를 할 수 있습니다.\nGradle빌드와 IntelliJ IDEA 빌드의 차이는 증분 빌드 여부입니다.\nIntelliJ IDEA는 변경된 부분만 빌드를 하는 방식으로 기존에 빌드가 돼 있는 부분은 건너뛰고 새로 변경된 부분만 빌드하는 방식입니다.\n그렇기 때문에 Gradle빌드 보다 더 빠르게 빌드할 수 있습니다. 하지만, IntelliJ IDEA는 기존에 빌드한 파일이 삭제된 경우도 같이 빌드가 될 수 있습니다. 그래서 종종 queryDSL과 mapStruct와 같이 컴파일 후 사용하는 코드가 빌드가 잘 안될 경우가 있을 수 있습니다.(반복적인 클린 -\u0026gt; 빌드 -\u0026gt; 리빌드 재귀..)\n올바르게 빌드를 하고 싶다면 Gradle로 하는 것도 좋은 전략이라 생각합니다.\n3. encoding UTF-8로 변경 인코딩이 encoding x-windows-949로 설정돼 있는 경우 아래와 같이 UTF-8로 변경하는 것이 좋습니다.\nx-windows-949란 한글 인코딩의 한 종류이며 EUC-KR의 확장형입니다. 오래전 마이크로소프트가 개발했던 한글 인코딩입니다.\n이것도 잘못하여 꼬이면 Swagger UI의 글자가 깨지는 경우가 발생할 수 있습니다.\n위 3가지는 프로젝트 생성 후 한번 쯤 확인해보면 좋은 것이라 생각되네요.\n4. 파일 끝에 개행을 자동으로 추가하기 행의 끝은 개행(EOL, end of line)으로 끝나는 것이 POSIX(Portable Operating System Interface) 표준이라고 합니다. 이와 같은 설정을 하지 않은 경우 예기치 않은 동작이 일어날 수 있기에 기본적으로 설정을 하시면 좋습니다.\n설정에서 Ensure every saved file ends with a line break를 체크해주시면 됩니다.\nReference 잘 알려지지 않은 Kotlin에서 빠른 컴파일의 비밀 Gradle \u0026amp; Build 그리고 IntelliJ의 Build 증분 빌드란 https://namu.wiki/w/CP949 ","permalink":"https://haservi.github.io/posts/spring/spring-intellij-start-setting/","summary":"인텔리J에서 스프링 프로젝트를 생성하면 아래 셋팅은 미리 설정하면 좋습니다.\n1. 어노테이션 프로세싱 활성화 롬복과 같은 외부 라이브러리를 의존성 주입하게 될 경우 해당 사항을 체크해줘야 컴파일 시 문제 없이 동작합니다.\n설정에서 검색창에 annotation을 입력하면 아래와 같은 화면이 나옵니다.\n2. Build and run IntelliJ IDEA로 변경 IntelliJ IDEA 인텔리제이 자체에서 제공하는 빌드 자동화 도구입니다.\n기본은 Gradle로 설정 돼 있습니다. 이걸 IntelliJ IDEA로 변경하면 더 빠른 테스트를 할 수 있습니다.\nGradle빌드와 IntelliJ IDEA 빌드의 차이는 증분 빌드 여부입니다.","title":"IntelliJ에서 스프링 프로젝트 관련 설정"},{"content":"Docker 메모리 프로세서 제어 Docker를 사용하다 보면 아래처럼 치솟는 메모리 사용량을 볼 때가 있습니다.\n아래의 방법은 Docker를 테스트 중 메모리 사용량을 Windows에서 제어 하는 방법입니다.\n탐색기의 사용자 위치(C:\\Users\\\u0026lt;사용자\u0026gt;)에 .wslconfig 파일을 생성합니다.\n아래와 같이 해당 파일의 설정을 지정합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 # 설정은 WSL 2에서 실행되는 모든 Linux 배포판에 적용 [wsl2] # VM 메모리를 4GB 이하로 제한. # GB 또는 MB를 사용하여 정수로 설정할 수 있음 memory=4GB # 2개의 가상 프로세서를 사용하도록 VM을 설정 processors=2 # 스왑 저장 공간의 양을 8GB로 설정합니다. 기본값은 사용 가능한 RAM의 25%입니다. swap=8GB 위 설정을 적용 후 Docker를 재실행해야 적용됩니다.\nMac의 경우는 Mac버전의 Docker Desktop 설정에서 간단하게 변경(링크) 할 수 있습니다.\nvmmem 터미널 강제 종료 Docker도 결국은 가상머신에서 돌고 있는 시스템이기에 WSL(Windows Subsystem for Linux)을 강제 종료하면 메모리와 CPU 점유율을 낮출 수 있습니다.\n좋은 방법은 아니지만 즉각적인 효과는 있습니다.\n커맨드 또는 powershell을 이용하여 아래의 명령어를 입력합니다.\n1 wsl --shutdown 위의 명령어로 WSL 강제 종료 후 Docker를 재실행하기 위해서는 Docker Desktop이 실행되어 있다면 우측하단의 트레이 아이콘에서 Troubleshoot을 선택합니다.\n선택 후 아래 사진과 같이 Restart를 선택하면 됩니다.\nReference https://docs.microsoft.com/ko-kr/windows/wsl/wsl-config https://stackoverflow.com/questions/64165192/stopping-vmmem-from-using-ram https://docs.docker.com/desktop/mac/ ","permalink":"https://haservi.github.io/posts/devops/docker/docker-smemory-controll-and-exit/","summary":"Docker 메모리 프로세서 제어 Docker를 사용하다 보면 아래처럼 치솟는 메모리 사용량을 볼 때가 있습니다.\n아래의 방법은 Docker를 테스트 중 메모리 사용량을 Windows에서 제어 하는 방법입니다.\n탐색기의 사용자 위치(C:\\Users\\\u0026lt;사용자\u0026gt;)에 .wslconfig 파일을 생성합니다.\n아래와 같이 해당 파일의 설정을 지정합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 # 설정은 WSL 2에서 실행되는 모든 Linux 배포판에 적용 [wsl2] # VM 메모리를 4GB 이하로 제한. # GB 또는 MB를 사용하여 정수로 설정할 수 있음 memory=4GB # 2개의 가상 프로세서를 사용하도록 VM을 설정 processors=2 # 스왑 저장 공간의 양을 8GB로 설정합니다.","title":"Docker 메모리 제한 설정 및 강제 종료"},{"content":"주로 DB를 관리하는 툴로 HeidiSQL를 많이 사용했습니다.\nSpring Data JPA와 QueryDSL 조합을 이용한 뒤로 어느 정도 익숙해지고 나서는 쿼리를 짜는 일이 많이 없지만, 조금 복잡한 쿼리의 경우는 쿼리를 작성해보고 성능 체크 후 QueryDSL로 변환하여 작업합니다.\n하지만 Mac환경에서는 HeidiSQL이 Mac을 지원하지 않기 때문에 다른 DB 툴을 사용해야 합니다.\nMac을 지원하는 다양한 DB툴 중에 평가가 꽤 괜찮은 DBeaver링크에 대해 알아보겠습니다.\nDbeaver 란? DBeaver는 Windows와 Mac 모두 지원 거의 모든 Database를 지원(MySQL, PostgreSQL, MariaDB, SQLite, Oracle, DB2, SQL Server\u0026hellip;) 오픈 소스 기반으로 다양한 확장 플러그인 지원 Entity Diagarm 지원 DB 내보내기 불러오기 지원 Community 버전을 이용해도 위와 같은 기능을 모두 사용할 수 있습니다.\n바로 다운로드하여 사용해도 되지만 기본적인 테마와 설정을 조금 변경하는 방법입니다.\n테마 뿐만아니라 다양한 확장 플러그인을 지원하기 때문에 필요한 것은 플러그인 검색하면 필요하다고 생각하는 왠만한 것은 나오는 것 같습니다.\n테마 변경 방법 테마 변경은 Mac기준으로 변경 했습니다. Windows도 비슷하긴 하지만 아래처럼 프로그램 재실행 팝업이 뜨면 아니오를 선택하고, 해당 프로그램을 관리자 권한으로 실행해야 합니다.(이후에는 그냥 실행 문제 없음)\n경고\nWindows의 경우 테마 설치 후 아니오를 선택 한 뒤 관리자 권한으로 실행해야합니다.\n그렇지 않으면 무한 재부팅 됩니다. 도움말선택 후 install new software를 선택합니다. 사이트 URL에 https://www.genuitec.com/updates/devstyle/ci/를 입력하고 아래의 그림처럼 선택 후 다음 선택합니다. 정상적으로 설치하면 프로그램 이 다시 실행된 후 아래와 같은 화면이 됩니다. 설정 커스텀 설정 커스텀은 쿼리 입력 방법과 결과 출력화면 단축키 들을 변경합니다.\n이 부분은 개인의 성향 차이가 크기 때문에 그냥 참고용으로 보는 것도 괜찮을 것 같습니다.\n설정은 Commend + ,로 진입하거나 아래처럼 선택하면 됩니다. 문서 편집기 설정 및 표시 설정 변경입니다. 쿼리 실행 시 Blank 구분자 설정 제외(여러 쿼리 실행 시 오류 방지) Select 결과 컬럼 높이 행 맞춤 및 헤더에 코멘트 출력 쿼리 작성 시 자동완성 기능 해제 컬럼 위치 변경 단축키 지정 자주 쓰는 단축키 단축키는 공식 문서에 잘 나와있으며, 자주 쓰는 단축키는 아래와 같습니다.\n기능 Windows Mac 쿼리 자동 완성 Ctrl+Space ⌃Space 쿼리 실행 Ctrl+Enter ⌃↩ 새로고침 Ctrl+F5 ⌘F5 해당스크립트의 다음 쿼리 ALT+Up ⌃⇧↑ 해당스크립트의 이전 쿼리 Alt+Down ⌃⇧↓ 이외에도 많은 단축키가 있습니다.\n","permalink":"https://haservi.github.io/posts/tools/how-to-dbeaver/","summary":"주로 DB를 관리하는 툴로 HeidiSQL를 많이 사용했습니다.\nSpring Data JPA와 QueryDSL 조합을 이용한 뒤로 어느 정도 익숙해지고 나서는 쿼리를 짜는 일이 많이 없지만, 조금 복잡한 쿼리의 경우는 쿼리를 작성해보고 성능 체크 후 QueryDSL로 변환하여 작업합니다.\n하지만 Mac환경에서는 HeidiSQL이 Mac을 지원하지 않기 때문에 다른 DB 툴을 사용해야 합니다.\nMac을 지원하는 다양한 DB툴 중에 평가가 꽤 괜찮은 DBeaver링크에 대해 알아보겠습니다.\nDbeaver 란? DBeaver는 Windows와 Mac 모두 지원 거의 모든 Database를 지원(MySQL, PostgreSQL, MariaDB, SQLite, Oracle, DB2, SQL Server\u0026hellip;) 오픈 소스 기반으로 다양한 확장 플러그인 지원 Entity Diagarm 지원 DB 내보내기 불러오기 지원 Community 버전을 이용해도 위와 같은 기능을 모두 사용할 수 있습니다.","title":"DBeaver 커스텀 셋팅하기"},{"content":"종종 테스트 중 이전에 실행한 Port가 남아서 충돌나는 경우가 있습니다.\n기존에 존재하는 Port의 PID를 제거하면 삭제할 수 있습니다.\nPort 강제 종료 방법 먼저 windows + R 을 눌러 실행 스크립트를 열어주고 cmd를 입력하여 커맨드 창을 열어줍니다. 명령어로 netstat -a -o를 입력하면 현재 연결된 네트워크 상태를 볼 수 있습니다. 위와 같이 8080포트가 존재하면 우측에 있는 PID의 번호를 기억합니다. 여기서는 49480의 값입니다. taskkill /f /pid 49480을 입력하면 해당 8080포트를 제거할 수 있습니다. ","permalink":"https://haservi.github.io/posts/tips/window-port-taskkill/","summary":"종종 테스트 중 이전에 실행한 Port가 남아서 충돌나는 경우가 있습니다.\n기존에 존재하는 Port의 PID를 제거하면 삭제할 수 있습니다.\nPort 강제 종료 방법 먼저 windows + R 을 눌러 실행 스크립트를 열어주고 cmd를 입력하여 커맨드 창을 열어줍니다. 명령어로 netstat -a -o를 입력하면 현재 연결된 네트워크 상태를 볼 수 있습니다. 위와 같이 8080포트가 존재하면 우측에 있는 PID의 번호를 기억합니다. 여기서는 49480의 값입니다. taskkill /f /pid 49480을 입력하면 해당 8080포트를 제거할 수 있습니다. ","title":"윈도우 Port 강제 종료 방법"},{"content":"Visual Studio Code의 자동완성 기능 해제 방법 프로그램 실행 후 설정(Ctrl + , 또는 Command + ,)으로 들어간 후 검색항목에 intelliSense를 검색하면 여러 체크박스 리스트를 볼 수 있습니다.\n위(Show Classes)에서부터 아래(Show Words)까지 전부 체크 해제를 하면 자동완성 기능이 비활성화 됩니다.\n그렇지만 너무 많은 옵션이 있기 때문에 전부 클릭 해제하기가 귀찮은 경우 아래의 JSON으로 추가할 수 있습니다.\n오른쪽 위의 설정으로 들어가서 아래의 값들을 복사 후 붙여 넣어주면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \u0026#34;explorer.compactFolders\u0026#34;: false, \u0026#34;explorer.confirmDragAndDrop\u0026#34;: false, \u0026#34;editor.suggest.showConstants\u0026#34;: false, \u0026#34;editor.suggest.showConstructors\u0026#34;: false, \u0026#34;editor.suggest.showCustomcolors\u0026#34;: false, \u0026#34;editor.suggest.showDeprecated\u0026#34;: false, \u0026#34;editor.suggest.showEnumMembers\u0026#34;: false, \u0026#34;editor.suggest.showEnums\u0026#34;: false, \u0026#34;editor.suggest.showEvents\u0026#34;: false, \u0026#34;editor.suggest.showFields\u0026#34;: false, \u0026#34;editor.suggest.showFiles\u0026#34;: false, \u0026#34;editor.suggest.showFolders\u0026#34;: false, \u0026#34;editor.suggest.showFunctions\u0026#34;: false, \u0026#34;editor.suggest.showInterfaces\u0026#34;: false, \u0026#34;editor.suggest.showIssues\u0026#34;: false, \u0026#34;editor.suggest.showKeywords\u0026#34;: false, \u0026#34;editor.suggest.showMethods\u0026#34;: false, \u0026#34;editor.suggest.showModules\u0026#34;: false, \u0026#34;editor.suggest.showOperators\u0026#34;: false, \u0026#34;editor.suggest.showProperties\u0026#34;: false, \u0026#34;editor.suggest.showReferences\u0026#34;: false, \u0026#34;editor.suggest.showSnippets\u0026#34;: false, \u0026#34;editor.suggest.showStructs\u0026#34;: false, \u0026#34;editor.suggest.showTypeParameters\u0026#34;: false, \u0026#34;editor.suggest.showUnits\u0026#34;: false, \u0026#34;editor.suggest.showUsers\u0026#34;: false, \u0026#34;editor.suggest.showValues\u0026#34;: false, \u0026#34;editor.suggest.showVariables\u0026#34;: false, \u0026#34;editor.suggest.showWords\u0026#34;: false, \u0026#34;editor.suggest.showClasses\u0026#34;: false, \u0026#34;editor.suggest.showColors\u0026#34;: false 아래의 사진처럼 넣어주면 됩니다. 다시 자동완성 기능이 필요하면 위의 값들을 삭제하거나 intelliSense로 접근하여 해당 항목들을 체크하면 됩니다.\n","permalink":"https://haservi.github.io/posts/tips/visual-studio-code-auto-complete/","summary":"Visual Studio Code의 자동완성 기능 해제 방법 프로그램 실행 후 설정(Ctrl + , 또는 Command + ,)으로 들어간 후 검색항목에 intelliSense를 검색하면 여러 체크박스 리스트를 볼 수 있습니다.\n위(Show Classes)에서부터 아래(Show Words)까지 전부 체크 해제를 하면 자동완성 기능이 비활성화 됩니다.\n그렇지만 너무 많은 옵션이 있기 때문에 전부 클릭 해제하기가 귀찮은 경우 아래의 JSON으로 추가할 수 있습니다.\n오른쪽 위의 설정으로 들어가서 아래의 값들을 복사 후 붙여 넣어주면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \u0026#34;explorer.","title":"비쥬얼 스튜디오 코드에서 자동완성 해제하기"},{"content":"Git Commit git commit message convetion은 회사 또는 프로젝트 마다 다를 수 있습니다.\nmessage의 형태는 다를 수 있지만 기본적인 목적은 같습니다.\n잘 만들어진 git 커밋 메시지는 해당 프로젝트에서 작업하는 팀원과 미래의 자신에게 변경 사항에 대한 의미를 전달하기 위한 좋은 방법입니다.\n일반적으로 커밋 메시지는 다음과 같은 구조를 권장합니다.\n1 2 3 4 5 type: Subject body footer 보통 위와 같은 형태입니다.\n제목은 새로운 기능 추가인 경우 feat: Subject, Feat: Subject, Feat Subject, Feature Subject 등 조금씩 type의 형태가 다르지만 그건 프로젝트에 따라 일관되게 맞추면 됩니다.\n글자 수는 50자 이내로 작성하는 것이 좋으며, issue와 관련이 있다면 제목 옆에 (#issue nubmer)를 추가하는 것도 어떠한 이슈와 관련된 것인지 알기 쉽게 볼 수 있습니다.\n본문은 commit 내용에 대한 추가 설명입니다. 한 줄당 72자 이내로 작성 하는 것이 좋으며, 본문 내용의 경우 변경 사항에 대한 정보를 기입하는 것이 좋습니다.\n푸터는 이슈 트래커 참조 용도로 사용됩니다.\n보통 푸터에 종료 키워드와 이슈 번호를 함께 작성하면 해당 이슈가 종료 처리도 됩니다.\nType의 종류 Type의 종류도 강제적이지는 않습니다. 다만 아래의 정보면 충분히 설명이 가능합니다.\nFeat 새로운 기능 Fix 버그 수정 Docs 문서와 관련된 추가 수정 삭제 Style 코드의 의미에 영향을 주지 않는 변경 사항(공백, 서식, 세미콜론 누락 등) Refactor 버그를 수정하거나 기능을 추가하지 않는 코드 변경 Perf 성능을 향상시키는 코드 변경 Test 테스트 추가 Chore 빌드 프로세스 또는 라이브러리에 대한 변경 사항 제목 총 글자 수 50자 이내로 작성 마지막에 ., !, ? 같은 특수문자 제외 제목은 동사원형 형태로 추가 본문 간단한 변경 사항의 경우 작성할 필요 없음 한 줄 당 72자 이내로 작성 부연 설명 및 어떻게 보다는 무엇을 왜 변경했는지 기입 푸터 간단한 변경 사항의 경우 작성할 필요 없음 이슈 트래커 id를 작성할 때 사용 Reference 좋은 git 커밋 메시지를 작성하기 위한 7가지 약속 협업을 위한 git 커밋 컨벤션 설정하기 How to Write a Git Commit Message How to Write Good Commit Messages: A Practical Git Guide ","permalink":"https://haservi.github.io/posts/tips/git-commit-message-rule/","summary":"Git Commit git commit message convetion은 회사 또는 프로젝트 마다 다를 수 있습니다.\nmessage의 형태는 다를 수 있지만 기본적인 목적은 같습니다.\n잘 만들어진 git 커밋 메시지는 해당 프로젝트에서 작업하는 팀원과 미래의 자신에게 변경 사항에 대한 의미를 전달하기 위한 좋은 방법입니다.\n일반적으로 커밋 메시지는 다음과 같은 구조를 권장합니다.\n1 2 3 4 5 type: Subject body footer 보통 위와 같은 형태입니다.\n제목은 새로운 기능 추가인 경우 feat: Subject, Feat: Subject, Feat Subject, Feature Subject 등 조금씩 type의 형태가 다르지만 그건 프로젝트에 따라 일관되게 맞추면 됩니다.","title":"Git Commit 메시지 규칙"},{"content":"Windows는 line ending으로 CR(Carriage-Return, \\r)과 LF(Line Feed \\n)을 사용합니다. CRLF는 커서를 다음 라인의 맨앞으로 옮기는 표시이며, ↲ 이러한 표현입니다.\nMac, Linux(Unix 계열)의 경우 LF(Line Feed \\n)를 사용합니다. LF는 현재 위치에서 바로 아래로 이동하는 것을 의미하며, ↓ 와 같은 표현입니다.\n문제는 같은 작업 영역에서 같은 코드를 수정할 경우 windows와 mac의 코드가 일치하더라도 커서의 표현값이 다르기 때문에 충돌이 일어나는 경우가 발생합니다.\n해결 방법으로는 각 운영체제별로 git을 기준으로 LF로 맞춰주는 것입니다.\nWindows는 CRLF를 LF로 변경되도록 git config 설정 중 core.autocrlf를 설정해주면 됩니다. Mac은 기존 개행 형식으로 저장되도록 설정해줍니다.\ncore.autocrlf 는 text file 을 git object database 에 checkin, checkout 할 때 어떻게 처리할지를 설정하는 변수입니다.\nWindows 1 git config --global core.autocrlf true text file을 넣기전 CRLF를 LF로 변경합니다.\nMac 1 git config --global core.autocrlf input Mac, Linux(Unix 계열)의 경우 LF만 사용하기 때문에 input으로 설정하면 됩니다.\n위와 같은 설정은 결국 아래와 같은 그림과 같은 형태로 text 파일이 저장됩니다.\n","permalink":"https://haservi.github.io/posts/tips/git-crlf/","summary":"Windows는 line ending으로 CR(Carriage-Return, \\r)과 LF(Line Feed \\n)을 사용합니다. CRLF는 커서를 다음 라인의 맨앞으로 옮기는 표시이며, ↲ 이러한 표현입니다.\nMac, Linux(Unix 계열)의 경우 LF(Line Feed \\n)를 사용합니다. LF는 현재 위치에서 바로 아래로 이동하는 것을 의미하며, ↓ 와 같은 표현입니다.\n문제는 같은 작업 영역에서 같은 코드를 수정할 경우 windows와 mac의 코드가 일치하더라도 커서의 표현값이 다르기 때문에 충돌이 일어나는 경우가 발생합니다.\n해결 방법으로는 각 운영체제별로 git을 기준으로 LF로 맞춰주는 것입니다.\nWindows는 CRLF를 LF로 변경되도록 git config 설정 중 core.","title":"git CRLF 개행 문자 차이 해결 방법"},{"content":"우선순위 큐(Priority Queue) 란? 우선순위 큐(Priority Queue)는 일반적인 큐의 구조와 달리 들어가는 순서와 상관없이 정의한대로 우선순위를 먼저 결정하고 그 우선순위가 높은 데이터가 먼저 나가는 자료구조 입니다. 그렇기 때문에 dequeue를 하면 이미 정의한 순서에 맞게 가장 위의 값이 나타납니다.\n우선순위 큐는 힙을 기반으로 하는 완전이진트리로 우선순위를 정하게 됩니다.\n사용 방법 우선순위 큐는 우선순위가 꼭 필요한 경우에 사용합니다. 람다식으로 정의해도 되고 Comparable을 이용해서 정의해도 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 낮은 숫자가 우선순위가 높은 방식 PriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(); // 높은 숫자가 우선순위가 높은 방식 PriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(Collections.reverseOrder()); // 이중 배열에서 0번째 낮은 숫자가 우선순위가 높은 방식(람다식) PriorityQueue\u0026lt;int[]\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((o1, o2) -\u0026gt; o1[0] - o2[0]); // 이중 배열에서 0번째 낮은 숫자가 우선순위가 높은 방식(Comparator) PriorityQueue\u0026lt;int[]\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(new Comparator\u0026lt;int[]\u0026gt;() { @Override public int compare(int[] o1, int[] o2) { return o1[0] - o2[0]; }; }); 위 처럼 다양한 방법으로 우선순위를 정할 수 있습니다.\n간단한 예제 및 원리 간단히 예를 들어 가장 작은 수를 기준으로 우선순위 큐를 만들면\n1 2 3 4 5 6 7 8 PriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(); pq.offer(1); pq.offer(2); pq.offer(3); pq.offer(4); pq.offer(5); pq.offer(6); pq.offer(7); 의 형태로 만들어집니다.\n그렇지만 각각 enqueue할 때는 이진트리의 마지막부분에서 조건에 맞게 값이 들어가는거죠.\n위의 경우는 가장작은 수부터 차례로 들어가기 때문에 swap을 하지 않고 값이 들어가게됩니다.\n그렇지만 만약 큰 수부터 우선순위 큐를 하게 되면\n1 2 3 4 5 6 7 8 PriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(Collections.reverseOrder()); pq.offer(1); pq.offer(2); pq.offer(3); pq.offer(4); pq.offer(5); pq.offer(6); pq.offer(7); 의 형태로 만들어집니다. 위의 순서를 그림으로 그리면 아래와 같은 순서로 완전 이진트리 형태로 값이 들어갑니다.\n조건에 맞게 우선 가장 마지막 노드에 값이 들어가고 부모와 비교를 해서 자신의 위치를 찾아가는 것이죠.\n반대로 dequeue인 poll()의 경우는 우선 Root를 제거하고 가장 마지막의 노드를 Root로 가져온 뒤 자식노드 중 자신보다 우선순위가 높은 값이 있다면 Swap을 하여 자신의 위치를 찾아가는 식입니다.\n1 2 3 while (!pq.isEmpty()) { pq.poll(); } 실제로 코드 내부로 들어가면 enqueue의 경우는 아래와 같이 Comparable로 정의하고 부모 노드와 현재 노드를 변경하는 코드가 들어가 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 public boolean offer(E e) { if (e == null) throw new NullPointerException(); modCount++; int i = size; if (i \u0026gt;= queue.length) grow(i + 1); siftUp(i, e); size = i + 1; return true; } private void siftUp(int k, E x) { if (comparator != null) siftUpUsingComparator(k, x, queue, comparator); else siftUpComparable(k, x, queue); } private static \u0026lt;T\u0026gt; void siftUpComparable(int k, T x, Object[] es) { Comparable\u0026lt;? super T\u0026gt; key = (Comparable\u0026lt;? super T\u0026gt;) x; while (k \u0026gt; 0) { int parent = (k - 1) \u0026gt;\u0026gt;\u0026gt; 1; Object e = es[parent]; if (key.compareTo((T) e) \u0026gt;= 0) break; es[k] = e; k = parent; } es[k] = key; } private static \u0026lt;T\u0026gt; void siftUpUsingComparator( int k, T x, Object[] es, Comparator\u0026lt;? super T\u0026gt; cmp) { while (k \u0026gt; 0) { int parent = (k - 1) \u0026gt;\u0026gt;\u0026gt; 1; Object e = es[parent]; if (cmp.compare(x, (T) e) \u0026gt;= 0) break; es[k] = e; k = parent; } es[k] = x; } 마찬가지로 dequeue의 경우도 Comparable로 정의하고 child 노드와 현재 노드를 변경하는 식의 코드가 들어있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 public E poll() { final Object[] es; final E result; if ((result = (E) ((es = queue)[0])) != null) { modCount++; final int n; final E x = (E) es[(n = --size)]; es[n] = null; if (n \u0026gt; 0) { final Comparator\u0026lt;? super E\u0026gt; cmp; if ((cmp = comparator) == null) siftDownComparable(0, x, es, n); else siftDownUsingComparator(0, x, es, n, cmp); } } return result; } private static \u0026lt;T\u0026gt; void siftDownComparable(int k, T x, Object[] es, int n) { // assert n \u0026gt; 0; Comparable\u0026lt;? super T\u0026gt; key = (Comparable\u0026lt;? super T\u0026gt;)x; int half = n \u0026gt;\u0026gt;\u0026gt; 1; // loop while a non-leaf while (k \u0026lt; half) { int child = (k \u0026lt;\u0026lt; 1) + 1; // assume left child is least Object c = es[child]; int right = child + 1; if (right \u0026lt; n \u0026amp;\u0026amp; ((Comparable\u0026lt;? super T\u0026gt;) c).compareTo((T) es[right]) \u0026gt; 0) c = es[child = right]; if (key.compareTo((T) c) \u0026lt;= 0) break; es[k] = c; k = child; } es[k] = key; } private static \u0026lt;T\u0026gt; void siftDownUsingComparator( int k, T x, Object[] es, int n, Comparator\u0026lt;? super T\u0026gt; cmp) { // assert n \u0026gt; 0; int half = n \u0026gt;\u0026gt;\u0026gt; 1; while (k \u0026lt; half) { int child = (k \u0026lt;\u0026lt; 1) + 1; Object c = es[child]; int right = child + 1; if (right \u0026lt; n \u0026amp;\u0026amp; cmp.compare((T) c, (T) es[right]) \u0026gt; 0) c = es[child = right]; if (cmp.compare(x, (T) c) \u0026lt;= 0) break; es[k] = c; k = child; } es[k] = x; } ","permalink":"https://haservi.github.io/posts/algorithms/priority-queue/","summary":"우선순위 큐(Priority Queue) 란? 우선순위 큐(Priority Queue)는 일반적인 큐의 구조와 달리 들어가는 순서와 상관없이 정의한대로 우선순위를 먼저 결정하고 그 우선순위가 높은 데이터가 먼저 나가는 자료구조 입니다. 그렇기 때문에 dequeue를 하면 이미 정의한 순서에 맞게 가장 위의 값이 나타납니다.\n우선순위 큐는 힙을 기반으로 하는 완전이진트리로 우선순위를 정하게 됩니다.\n사용 방법 우선순위 큐는 우선순위가 꼭 필요한 경우에 사용합니다. 람다식으로 정의해도 되고 Comparable을 이용해서 정의해도 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 낮은 숫자가 우선순위가 높은 방식 PriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(); // 높은 숫자가 우선순위가 높은 방식 PriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(Collections.","title":"Java Priority Queue(우선순위 큐) 원리 및 사용 방법"},{"content":"H2를 최신 버전(2.1.210)으로 업데이트하니 아래와 같은 에러가 발생했습니다.\n1 2 3 4 5 6 7 8 Caused by: org.hibernate.HibernateException: Access to DialectResolutionInfo cannot be null when \u0026#39;hibernate.dialect\u0026#39; not set ... java.lang.IllegalStateException: Failed to load ApplicationContext at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:132) at org.springframework.test.context.support.DefaultTestContext.getApplicationContext(DefaultTestContext.java:124) at org.springframework.test.context.web.ServletTestExecutionListener.setUpRequestContextIfNecessary(ServletTestExecutionListener.java:190) ... 일단 임시방편으로 H2 url을 연결하는 곳에 추가적으로 옵션(;MODE=LEGACY)을 넣으면 해결됩니다.\n1 url: jdbc:h2:tcp://localhost/~/test;MODE=LEGACY MODE=LEGACY를 모드를 사용하면 H2 1.X용으로 작성된 응용 프로그램에 대한 일부 호환성 기능이 활성화됩니다. Hibernate ORM에서 H2에 대해서 유효하지 않은 SQL을 생성하기 때문이라고 합니다.\n그렇다면.. hibernate ORM에서 H2 방언에 대한 문제를 해결해야 합니다.\n현재는 hibernate ORM은 5.6 안정화 버전과 6.0 개발 버전이 있습니다.\nReference Upgrade H2 version 2.0.202 from 1.4.200 h2database document ","permalink":"https://haservi.github.io/posts/spring/h2-version-upgrade-error/","summary":"H2를 최신 버전(2.1.210)으로 업데이트하니 아래와 같은 에러가 발생했습니다.\n1 2 3 4 5 6 7 8 Caused by: org.hibernate.HibernateException: Access to DialectResolutionInfo cannot be null when \u0026#39;hibernate.dialect\u0026#39; not set ... java.lang.IllegalStateException: Failed to load ApplicationContext at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:132) at org.springframework.test.context.support.DefaultTestContext.getApplicationContext(DefaultTestContext.java:124) at org.springframework.test.context.web.ServletTestExecutionListener.setUpRequestContextIfNecessary(ServletTestExecutionListener.java:190) ... 일단 임시방편으로 H2 url을 연결하는 곳에 추가적으로 옵션(;MODE=LEGACY)을 넣으면 해결됩니다.\n1 url: jdbc:h2:tcp://localhost/~/test;MODE=LEGACY MODE=LEGACY를 모드를 사용하면 H2 1.X용으로 작성된 응용 프로그램에 대한 일부 호환성 기능이 활성화됩니다. Hibernate ORM에서 H2에 대해서 유효하지 않은 SQL을 생성하기 때문이라고 합니다.","title":"H2 2.1.210 Upgrade시 JPA 테스트 에러 해결 방법"},{"content":"JPQL 이란? 예전에는 JPQL은 Java Persistence Query Language로 불렸지만 현재의 JPQL은(Jakarta Persistence Query Language) 라고 합니다.(나무위키 링크)\n2019년부터 JPA(Java Persistence API)또한 Jakarta Persistence로 변경됐습니다.\n이름은 달라졌지만 역할은 달라지지 않았습니다. JPQL을 이용하여 관계형 데이터베이스의 엔티티를 정의하고 이를 활용한 쿼리 언어를 자바를 이용하여 구현합니다.\n더 나아가 Querydsl을 이용하면 좀 더 직관적이고 오류 없이 자바를 이용하여 작성할 수 있습니다.\n간단한 예시로 회원 조회를 하는 경우 JPQL과 Querydsl의 차이는 아래와 같습니다.\nJPQL\n1 2 3 4 5 6 public List\u0026lt;Member\u0026gt; findAll() { EntityManager entityManager; return entityManager.createQuery(\u0026#34;select m from Member m \u0026#34;, Member.class) .getResultList(); } Querydsl\n1 2 3 4 5 6 7 public List\u0026lt;Member\u0026gt; findAll() { JPAQueryFactory queryFactory; return queryFactory .selectFrom(QMember.member) .fetch(); } 결국은 같은 결과를 호출하지만 Querydsl을 이용하면 쿼리작성 및 빌드 오류를 컴파일 시점에 방지할 수 있습니다.\n가독성도 Querydsl쪽이 더 좋습니다.\nSpring Data JPA란? CRUD 처리를 위한 공통 인터페이스를 JPA에서 미리 만들어 놓은 것입니다.\n일반적으로 Entity 어노테이션을 선언한 클래스를 매개변수로 JpaRepository 인터페이스를 상속받아 사용합니다.\n이렇게되면 실제로 SQL관련 코드하나 사용하지 않고 간단한 CRUD는 처리가 가능합니다.\n사용자 정의 인터페이스 상속받기 인터페이스는 다중상속이 가능하기 때문에 먼저 CustomRepository를 인터페이스로 생성합니다.\n1 2 3 public interface CustomMemberRepository { void customSave(Member member); } 그리고 구현체에 해당 선언한 함수들을 구현합니다.\n1 2 3 4 5 6 7 8 9 @RequiredArgsConstructor public class CustomMemberRepositoryImpl implements CustomMemberRepository { private final EntityManager em; @Override public void customSave(Member member) { em.persist(member); } } 마지막으로 직접사용할 인터페이스에 위의 인터페이스를 추가합니다.\n1 2 3 public interface MemberRepository extends JpaRepository\u0026lt;Member, Long\u0026gt;, CustomMemberRepository { } 위와 같이 스프링 데이터 JPA에서 제공하는 기능과 필요한 기능이 복잡해짐에 따른 커스텀 쿼리를 인터페이스화 하여 함께 사용할 수 있습니다.\n같은 결과라도 memberRepository.customSave(member)와 memberRepository.save(member)의 방식이 다릅니다.\n아래는 package org.springframework.data.jpa.repository.support;에서 구현된 save(S entity) 구현체 입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Transactional @Override public \u0026lt;S extends T\u0026gt; S save(S entity) { Assert.notNull(entity, \u0026#34;Entity must not be null.\u0026#34;); if (entityInformation.isNew(entity)) { em.persist(entity); return entity; } else { return em.merge(entity); } } 스프링 데이터 JPA에서 제공하는 함수 가이드 링크 입니다.\n","permalink":"https://haservi.github.io/posts/spring/springdatajpa-and-customquery/","summary":"JPQL 이란? 예전에는 JPQL은 Java Persistence Query Language로 불렸지만 현재의 JPQL은(Jakarta Persistence Query Language) 라고 합니다.(나무위키 링크)\n2019년부터 JPA(Java Persistence API)또한 Jakarta Persistence로 변경됐습니다.\n이름은 달라졌지만 역할은 달라지지 않았습니다. JPQL을 이용하여 관계형 데이터베이스의 엔티티를 정의하고 이를 활용한 쿼리 언어를 자바를 이용하여 구현합니다.\n더 나아가 Querydsl을 이용하면 좀 더 직관적이고 오류 없이 자바를 이용하여 작성할 수 있습니다.\n간단한 예시로 회원 조회를 하는 경우 JPQL과 Querydsl의 차이는 아래와 같습니다.\nJPQL\n1 2 3 4 5 6 public List\u0026lt;Member\u0026gt; findAll() { EntityManager entityManager; return entityManager.","title":"Spring Data JPA와 JPQL 함께 사용하기"},{"content":"Mybatis란? 자바의 관계형 데이터베이스 프로그래밍을 좀 더 쉽게 할 수 있게 도와 주는 개발 프레임 워크입니다.\nJDBC를 통해 데이터베이스에 엑세스하는 작업을 캡슐화하고 일반 SQL 쿼리, 저장 프로시저 및 고급 매핑을 지원하며 모든 JDBC 코드 및 매개 변수의 중복작업을 제거 합니다.\n또한 Java코드와 SQL코드를 분리하여 서로 다른 역할에 집중할 수 있게 합니다.\nMyBatis는 DAO(Data Access Object)인터페이스를 통해 SQL과 연결 후 VO(Value Object) 또는 DTO(Data Transfer Object)로 바로 데이터를 가져옵니다.\nJPA란? JPA(Java Persistence API)는 ORM(Object-Relational Mapping) 기술 표준으로 JPA가 제공하는 API를 사용하면 직접적으로 SQL을 사용하지 않고도 DB에 접근이 가능합니다.\nJPA는 반복적인 CRUD 작업을 이미 인터페이스에서 제공하고 있습니다. JPA를 제대로 사용하기 위해서는 약간의 러닝커브가 존재하지만 익숙해지면 빠른 개발과 유지보수 측면에서 효율적입니다.\nJPA는 Entity와 DTO(Data Transper Object)를 구분지어서 정의하는 것이 좋습니다. 컨트롤러에서는 DTO를 통해 유효성검사 및 FrontEnd와의 연결을 책임지며, DB와 관련된 것은 Entity로 제어 하는거죠. 이러한 Object Mapping은 직접 함수를 만들거나 라이브러리를 이용해도 됩니다.\n자주 사용하는 라이브러리는 Model Mapper와 Map Struct가 대표적이며, 성능 이슈가 적은 Map Struct 사용을 추천합니다.\n일반적으로 JPA는 Spring Data JPA와 Querydsl 조합을 많이 사용합니다.\nMabatis or JPA 그렇지만 현재의 구글 트렌드를 검색해보면 전세계적으로는 압도적으로 JPA가 우위에 있으며 우리나라의 경우는 비슷한 정도로 나타납니다.\nJPA와 MyBatis와의 차이점이라면 DB를 바라보는 관점이 다른 것 같습니다.\n서로의 장단점이 있기 때문에 프로젝트의 성격과 적합도에 맞게 선택하는 것이 좋을 것 같습니다.\nJPA가 조금 더 공부해야 할 것이 많긴 하지만 잘 이해하고 사용하면 유지보수하기 좋을 것 같다 생각합니다.😓\n","permalink":"https://haservi.github.io/posts/spring/mybatis-and-jpa/","summary":"Mybatis란? 자바의 관계형 데이터베이스 프로그래밍을 좀 더 쉽게 할 수 있게 도와 주는 개발 프레임 워크입니다.\nJDBC를 통해 데이터베이스에 엑세스하는 작업을 캡슐화하고 일반 SQL 쿼리, 저장 프로시저 및 고급 매핑을 지원하며 모든 JDBC 코드 및 매개 변수의 중복작업을 제거 합니다.\n또한 Java코드와 SQL코드를 분리하여 서로 다른 역할에 집중할 수 있게 합니다.\nMyBatis는 DAO(Data Access Object)인터페이스를 통해 SQL과 연결 후 VO(Value Object) 또는 DTO(Data Transfer Object)로 바로 데이터를 가져옵니다.\nJPA란? JPA(Java Persistence API)는 ORM(Object-Relational Mapping) 기술 표준으로 JPA가 제공하는 API를 사용하면 직접적으로 SQL을 사용하지 않고도 DB에 접근이 가능합니다.","title":"Mybatis와 JPA에 대하여"},{"content":"@Autowired는 필드 주입이고, @RequiredArgsConstructor는 생성자 주입(Constructor Injection) 입니다.\n@RequiredArgsConstructor는 Lombok에서 제공하는 어노테이션 입니다.\n결론적으로 생성자 주입을 권장합니다. 인텔리제이에서 코드를 작성하다보면 @Autowired를 사용하면 아래와 같은 경고를 알려줍니다.\n경고\nField injection is not recommended\nInspection info: Spring Team recommends: \u0026ldquo;Always use constructor based dependency injection in your beans. Always use assertions for mandatory dependencies\u0026rdquo;.\n뭐.. 추천하지 않고 생성자 주입방식을 쓰라고 하는거 같네요.\n생성자 주입으로 코드를 작성하면 아래와 같은 장점이 있습니다.\n순환 참조 방지 테스트 코드 작성 용이 코드 악취 제거 객체 변이 방지 필드 주입방식을 쓰면 아래와 같은 단점이 있습니다.\n단일 책임의 원칙 위반 숨은 의존성 제공 의존성을 가진 클랙스를 곧바로 인스턴스화 할 수 없음 final을 선언할 수 없기 때문에 객체가 변할 수 있음 Lombok를 쓰면 아래와 같이 간단하게 처리 할 수 있습니다.\n1 2 3 4 5 6 7 @Controller @RequiredArgsConstructor public class ItemController { private final ItemService itemService; private final OrderService orderService; } 만약 Lombok을 사용하지 않으면 아래와 같이 처리해야 합니다. 아래와 같이 생성자가 1개인 경우는 @Autowired를 생략해도 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 @Controller public class ItemController { private final ItemService itemService; private final OrderService orderService; @Autowired public ItemController(final ItemService itemService, final OrderService orderService) { this.itemService = itemService; this.orderService = orderService; } } ","permalink":"https://haservi.github.io/posts/spring/diff-requiredargsconstructor-autowired/","summary":"@Autowired는 필드 주입이고, @RequiredArgsConstructor는 생성자 주입(Constructor Injection) 입니다.\n@RequiredArgsConstructor는 Lombok에서 제공하는 어노테이션 입니다.\n결론적으로 생성자 주입을 권장합니다. 인텔리제이에서 코드를 작성하다보면 @Autowired를 사용하면 아래와 같은 경고를 알려줍니다.\n경고\nField injection is not recommended\nInspection info: Spring Team recommends: \u0026ldquo;Always use constructor based dependency injection in your beans. Always use assertions for mandatory dependencies\u0026rdquo;.\n뭐.. 추천하지 않고 생성자 주입방식을 쓰라고 하는거 같네요.\n생성자 주입으로 코드를 작성하면 아래와 같은 장점이 있습니다.\n순환 참조 방지 테스트 코드 작성 용이 코드 악취 제거 객체 변이 방지 필드 주입방식을 쓰면 아래와 같은 단점이 있습니다.","title":"@Autowired와 @RequiredArgsConstructor 차이점 "},{"content":"logitech options 란? 일부 로지텍 마우스 중에는 특정 소프트웨어를 지원하는 기능이 있습니다.\n그 중 logitech options는 Flow기능으로 기기간 파일전송이나 하나의 마우스로 여러대의 기기를 제어할 수 있습니다.\n이번에 소개해드릴 기능은 Flow기능이 아닌 마우스 제스처 모드에 따른 설정입니다.\n설치 해당 사이트에서 OS에 맞는 프로그램을 설치하면 됩니다.\n설치 후 정상적으로 마우스가 연결되면 아래와 비슷한 사진이 보입니다.\n커스텀 설정하기 프로그램 실행 후 흰색 동그라미가 있는 모든 버튼이 커스텀 가능합니다.\n저의 경우 뒤로가기와 앞으로가기 버튼만 커스텀하여 사용하고 있습니다.\n해당 프로그램은 특정 소프트웨어에서 다르게 커스텀을 적용할 수 있습니다. 아래는 제가 사용하는 입력할 키 지정 모드입니다.\n알림\n모든 이미지는 Windows를 기준으로 작성했으며, 응용 프로그램의 경우 공통 제스처모드이면 각각 설정값을 입력해야합니다.\n뒤로가기 버튼 뒤로가기 버튼의 제스처 모드는 2가지 입니다. 이것만 설정해도 매우 편하게 이용할 수 있습니다.\n공통 설명 제스처 Windows Mac 데스크탑 왼쪽 뒤로가기 버튼 클릭 + 왼쪽 이동 Ctrl + Window + ← control + ← 데스크탑 오른쪽 뒤로가기 버튼 클릭 + 오른쪽 이동 Ctrl + Window + → control + → 뒤로 뒤로가기 버튼 클릭 뒤로가기 뒤로가기 아래와 같이 설정했습니다.\n앞으로가기 버튼 앞으로가기 버튼의 경우 우측 상단의 프로그램마다 설정을 할 수 있습니다.\n코딩 시 디버깅을 할 때 IDE마다 조금씩 디버깅 버튼이 다를 수 있습니다. 그렇기 때문에 자주 사용하는 프로그램의 경우 디버깅 버튼을 단축키로 지정합니다.\n다음과 같이 모든 방향 제스처를 통일하였습니다.\n앞으로가기 버튼 클릭 + 위 : Step Out 앞으로가기 버튼 클릭 + 아래 : Step Into 앞으로가기 버튼 클릭 + 왼쪽 : Continue 앞으로가기 버튼 클릭 + 오른쪽 : Step Over 거의 대다수 프로그램이 위와 같은 디버깅 로직입니다. 그렇기 때문에 응용프로그램을 선택 후 입력할 키 지정만 올바르게 하면 IDE마다 동일한 제스처로 디버깅이 가능합니다.\n간단하게 Visual Studio Code와 Eclipse IntelliJ 정도만 설정하면 다음과 같습니다.\nSTS(Spring Tools) 설명 제스처 Windows Mac Step Out 앞으로가기 버튼 클릭 + 위 F7 F7 Step Into 앞으로가기 버튼 클릭 + 아래 F5 F5 Continue 앞으로가기 버튼 클릭 + 왼쪽 F8 F8 Step Over 앞으로가기 버튼 클릭 + 오른쪽 F6 F6 Visual Studio Code 설명 제스처 Windows Mac Step Out 앞으로가기 버튼 클릭 + 위 Shift + F11 Shift + F11 Step Into 앞으로가기 버튼 클릭 + 아래 F11 F11 Continue 앞으로가기 버튼 클릭 + 왼쪽 F5 F5 Step Over 앞으로가기 버튼 클릭 + 오른쪽 F10 F10 IntelliJ 설명 제스처 Windows Mac Step Out 앞으로가기 버튼 클릭 + 위 Shift + F8 Shift + F8 Step Into 앞으로가기 버튼 클릭 + 아래 F7 F7 Continue 앞으로가기 버튼 클릭 + 왼쪽 F9 F9 Step Over 앞으로가기 버튼 클릭 + 오른쪽 F8 F8 이외에도 마우스를 이용하여 다양한 옵션과 제스처를 설정할 수 있습니다.\n","permalink":"https://haservi.github.io/posts/tools/how-to-logitech-option/","summary":"logitech options 란? 일부 로지텍 마우스 중에는 특정 소프트웨어를 지원하는 기능이 있습니다.\n그 중 logitech options는 Flow기능으로 기기간 파일전송이나 하나의 마우스로 여러대의 기기를 제어할 수 있습니다.\n이번에 소개해드릴 기능은 Flow기능이 아닌 마우스 제스처 모드에 따른 설정입니다.\n설치 해당 사이트에서 OS에 맞는 프로그램을 설치하면 됩니다.\n설치 후 정상적으로 마우스가 연결되면 아래와 비슷한 사진이 보입니다.\n커스텀 설정하기 프로그램 실행 후 흰색 동그라미가 있는 모든 버튼이 커스텀 가능합니다.\n저의 경우 뒤로가기와 앞으로가기 버튼만 커스텀하여 사용하고 있습니다.","title":"Logitech Options를 이용한 마우스 커스텀하기"},{"content":"Git Command를 사용하면서 자주 사용하는 명령어를 정리했습니다.\n이외에도 수많은 명령어가 존재하지만 작업과 관련된 명령어는 아래의 경우로 충분하다고 생각합니다.\n해당 명령어 이외에 더 참고하고 싶다면 https://git-scm.com/book/ko/v2 해당 사이트에서 무료로 책을 다운로드 받아서 볼 수 있습니다.\n또한, 요즘은 소스트리(https://www.sourcetreeapp.com/)에서 GUI로 편하게 작업할 수 도 있습니다.\n기본적인 명령어는 숙지하는 것이 좋지만 history나 간단한 업무용으로는 충분하다고 생각합니다.\n기본 명령어 git 설정 보기\n1 git config --list 사용자 이름 입력\n1 git config --global user.name \u0026#34;이름\u0026#34; 사용자 이메일 입력\n1 git config --global user.email \u0026#34;이메일\u0026#34; 자주쓰는 명령어 작업과 관련된 명령어 git branch 정보보기\n1 git branch -a git branch 변경하기\n1 git checkout 브랜치명 stash에 작업 코드 넣어두기\n1 2 3 git stash # 코드 넣기 git stash pop # 코드 빼기 git 코드 수정 관련 명령어 수정하거나 추가한 파일 모두 스테이지에 올리기\n1 2 3 4 5 // 전체 작업 한번에 올리기 git add -A // 특정 파일만 올리기 git add README.md(파일명) 스테이지에 올라간 코드 나의 작업에 Commit 하기\n1 git commit -m \u0026#34;작업한 코멘트\u0026#34; Git 작업 내역 확인하기\n1 git status Commit한 작업 내역 push 하기\n1 git push 자주는 안쓰지만 종종 써야하는 명령어 Git 삭제\n1 sudo apt-get remove git 이미 push한 최종 커밋 메시지 변경\n1 2 git commit --amend -m \u0026#34;변경할 메시지\u0026#34; git push origin 브랜치명 -f 가장 최근 push 제거\n1 2 3 git reset HEAD^ git commit -m \u0026#34;commit delete\u0026#34; git push origin 브랜치명 -f workspace작업 정보 stash에 저장\n1 git stash stash 목록 확인\n1 git stash list 가장 최근 stash 적용\n1 git stash apply 특정 stash 적용\n1 git stash apply [stash 이름] 가장 최근 stash 삭제\n1 git stash drop 특정 stash 삭제\n1 git stash drop [stash 이름] 설정과 관련된 명령어 한글 깨짐 현상 수정\n1 git config --global core.quotepath false Git 대소문자 인식(특정 git 폴더 내에서)\n1 git config core.ignorecase false ","permalink":"https://haservi.github.io/posts/tips/git-frequently-used-commands/","summary":"Git Command를 사용하면서 자주 사용하는 명령어를 정리했습니다.\n이외에도 수많은 명령어가 존재하지만 작업과 관련된 명령어는 아래의 경우로 충분하다고 생각합니다.\n해당 명령어 이외에 더 참고하고 싶다면 https://git-scm.com/book/ko/v2 해당 사이트에서 무료로 책을 다운로드 받아서 볼 수 있습니다.\n또한, 요즘은 소스트리(https://www.sourcetreeapp.com/)에서 GUI로 편하게 작업할 수 도 있습니다.\n기본적인 명령어는 숙지하는 것이 좋지만 history나 간단한 업무용으로는 충분하다고 생각합니다.\n기본 명령어 git 설정 보기\n1 git config --list 사용자 이름 입력\n1 git config --global user.name \u0026#34;이름\u0026#34; 사용자 이메일 입력","title":"자주 사용하는 Git Command 정리"},{"content":"Service, ServiceImpl Spring 프로젝트를 하면 종종 관례적으로 Service를 interface로 기능 명세를 한 뒤 ServiceImpl에 기능을 구현하게 되는 Factory Pattern을 사용하게 됩니다.\ninterface는 기능을 추상화하여 클래스간 결합도를 낮추어 주고, 협업 시 업무분담도 용이합니다.\n게임으로 예를 들면 스타크래프트에서 모든 유닛의 기본적인 특성 HP, 이동하기를 interface로 기능만 명시하고 각각 분업하여 유닛에 대한 HP나 이동속도를 구현할 수 있습니다.\n하지만 일반적인 Spring 웹프로젝트에서는 Service interface는 1:1 구조인 경우가 많습니다. 만약 확장성을 고려한 1:N의 경우에는 interface로 가는 것이 좋지만 너무 막연한 경우에는 그냥 class로 생성 후 추후 시나리오 변경 또는 로직상 확장성이 필요한 경우 interface로 변경하는 것이 좋다고 생각합니다.\n그렇다면 interface를 사용하는 경우는 어떤 경우에 사용해야할까요??\n보통 하나의 기능에서 여러 곳으로 파생되는 것을 interface로 나누는게 좋을 것 같습니다.\n예를 들어 소셜로그인, 패스워드 변경(개인정보수정, 패스워드찾기), 아이디 찾기(휴대폰 인증, 이메일 인증, 기타 등등), 카드 결제(카드사 별 결제 취소), 게임(게임별 플레이, 종료)등이 있습니다.\n공통적으로 쓰이는 기능을하나의 기능에서 충분히 확장될 수 있는 경우 interface를 사용하는 것이 좋습니다.\n로그인의 기능을 만들 때 Spring Security의 OAuth2를 이용하여 보통 기능 구현을 합니다.\n그렇지만 oauth2를 사용하지 않고 기능을 구현하는 경우를 샘플 코드를 이용하여 설명해보겠습니다.\n먼저 로그인 유형에 대한 정의를 합니다.\n1 2 3 4 5 6 7 public enum AuthProvider { local, google, kakao, github, naver } 그런 뒤 LoginService로 인터페이스를 생성합니다.\n1 2 3 public interface LoginService { LoginDto.Response login(LoginDto.Request dto); } 그리고 소셜에 따라 로그인 서비스에 맞게 구현 로직을 추가합니다. 이제 로그인 요청이 들어오면 해당 소셜 로그인이 동작하도록 LoginFactory 클래스를 생성합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public LoginService getLoginType(LoginDto.Request dto) { if (dto == null) { return null; } if (dto.getAuthProvider().equals(AuthProvider.github)) { return new LoginGithubService(); } else if (dto.getAuthProvider().equals(AuthProvider.google)) { return new LoginGoogleService(); } else if (dto.getAuthProvider().equals(AuthProvider.kakao)) { return new LoginKakaoService(); } else if (dto.getAuthProvider().equals(AuthProvider.naver)) { return new LoginGoogleService(); } else if (dto.getAuthProvider().equals(AuthProvider.local)) { return new LoginLocalService(); } return null; } 안의 내용들은 구현하지 않고 해당 로직을 타는지 print만 했습니다.\n위와 같이 구현하면 dto 요청에서 소셜 로그인 정보와 일치하는 Service의 로직이 동작합니다.\nTest코드로 확인하기 위해 정상적으로 하는지 확인해봅니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @Test void 로그인_타입_테스트() { LoginFactory loginFactory = new LoginFactory(); LoginDto.Request request = new LoginDto.Request(); LoginService loginService = new LoginLocalService(); request.setAuthProvider(AuthProvider.github); loginService = loginFactory.getLoginType(request); loginService.login(request); request.setAuthProvider(AuthProvider.google); loginService = loginFactory.getLoginType(request); loginService.login(request); request.setAuthProvider(AuthProvider.kakao); loginService = loginFactory.getLoginType(request); loginService.login(request); request.setAuthProvider(AuthProvider.naver); loginService = loginFactory.getLoginType(request); loginService.login(request); request.setAuthProvider(AuthProvider.local); loginService = loginFactory.getLoginType(request); loginService.login(request); } 테스트 코드를 통해 service가 정상적으로 동작하는지 확인 할 수 있습니다.\nReference https://www.manty.co.kr/bbs/detail/develop?id=13 https://itzjamie96.github.io/2021/01/24/spring-service-and-serviceimpl/ https://cheese10yun.github.io/spring-oop-04/ https://blog.jiniworld.me/55 https://www.tutorialspoint.com/design_pattern/factory_pattern.htm ","permalink":"https://haservi.github.io/posts/spring/service-and-serviceimp/","summary":"Service, ServiceImpl Spring 프로젝트를 하면 종종 관례적으로 Service를 interface로 기능 명세를 한 뒤 ServiceImpl에 기능을 구현하게 되는 Factory Pattern을 사용하게 됩니다.\ninterface는 기능을 추상화하여 클래스간 결합도를 낮추어 주고, 협업 시 업무분담도 용이합니다.\n게임으로 예를 들면 스타크래프트에서 모든 유닛의 기본적인 특성 HP, 이동하기를 interface로 기능만 명시하고 각각 분업하여 유닛에 대한 HP나 이동속도를 구현할 수 있습니다.\n하지만 일반적인 Spring 웹프로젝트에서는 Service interface는 1:1 구조인 경우가 많습니다. 만약 확장성을 고려한 1:N의 경우에는 interface로 가는 것이 좋지만 너무 막연한 경우에는 그냥 class로 생성 후 추후 시나리오 변경 또는 로직상 확장성이 필요한 경우 interface로 변경하는 것이 좋다고 생각합니다.","title":"[Spring] Service와 ServiceImpl에 대해"},{"content":"기본적으로 웹상에서는 Git 저장소 안의 폴더를 다운받으려면 해당 저장소 전부를 다운 받은 후에 특정 폴더의 정보를 봐야 합니다.\n간단한 방법은 아래의 링크에서 다운로드 받는게 제일 쉬운방법이지만 터미널에서 다운로드 방법도 한번 다루어보겠습니다. 터미널로 다운 받은 경우 이후 해당 소스가 변경이 있다면 당겨올 수 있는 이점도 있습니다.\n해결방법 웹 다운로드 https://downgit.github.io/#/home 해당 사이트에 github 저장소 특정 폴더의 링크를 복사 한 후 붙여넣고 Download 버튼 클릭\n터미널 다운로드 기본적으로 git이 설치돼 있어야합니다.\n예제로 https://github.com/android/architecture-components-samples/tree/main/NavigationAdvancedSample 해당 저장소를 다운받는다고 가정하겠습니다.\n폴더 생성 후 이동\n1 2 mkdir sample-code1 cd sample-code1 git 초기화\n1 git init git checkout 설정 변경\n1 git config core.sparseCheckout true 원하는 git 저장소 추가\n1 git remote add -f origin https://github.com/android/architecture-components-samples.git 원하는 특정 폴더 저장소 선택(window)\n1 echo NavigationAdvancedSample/* \u0026gt; .git/info/sparse-checkout 원하는 특정 폴더 저장소 선택(ubuntu)\n1 echo \u0026#34;NavigationAdvancedSample/*\u0026#34; \u0026gt; .git/info/sparse-checkout git 당기기(특정 브렌치 정보)\n1 git pull origin main 사소한 이슈이지만 Windows에서는 경로를 인용해서는 안된다고 하네요. 그렇기 때문에 \u0026ldquo;\u0026ldquo;을 붙이면 안됩니다(참고)\n","permalink":"https://haservi.github.io/posts/tips/git-inner-folder-download/","summary":"기본적으로 웹상에서는 Git 저장소 안의 폴더를 다운받으려면 해당 저장소 전부를 다운 받은 후에 특정 폴더의 정보를 봐야 합니다.\n간단한 방법은 아래의 링크에서 다운로드 받는게 제일 쉬운방법이지만 터미널에서 다운로드 방법도 한번 다루어보겠습니다. 터미널로 다운 받은 경우 이후 해당 소스가 변경이 있다면 당겨올 수 있는 이점도 있습니다.\n해결방법 웹 다운로드 https://downgit.github.io/#/home 해당 사이트에 github 저장소 특정 폴더의 링크를 복사 한 후 붙여넣고 Download 버튼 클릭\n터미널 다운로드 기본적으로 git이 설치돼 있어야합니다.\n예제로 https://github.","title":"Github 저장소 안의 폴더 다운로드 받는 방법"},{"content":"작업의 효율을 높이기 위해 기존 화면에서 필요한 정보를 잠시 동안 캡쳐하는 방법이 있습니다.\n캡쳐프로그램은 정말 다양하게 존재하는데요. 예를 들어 알캡쳐, picpic, 윈도우 기본 내장 캡쳐, pureRef, snipaste 등 많이 있습니다.\n저 같은 경우 포스팅 할 때 화면캡쳐 용도로는 picpick을 자주 이용하며, 업무 중 필요한 정보를 캡쳐 할 때는 snipaste를 사용합니다.\npicpick의 경우는 워낙 잘 알려져 있기 때문에 snipaste에 대해 알아보겠습니다.\nSnipaste (download link) Snipaste는 특정 화면을 지정하여 캡쳐하여 화면에 띄워놓을 수 있습니다.\nWindows는 지원하고 있으며, Mac의 경우 Beta테스트를 하는 것 같네요.\n기본적인 기능으로는 특정 화면 캡쳐, 캡쳐 화면 Color Picker, 캡쳐 화면 확대 축소, 캡쳐 화면 투명도 조절, 캡쳐 화면 저장, 캡쳐 화면 Annotation 지정 등이 있습니다.\n기본 버전으로도 충분히 이용할 수 있지만, pro버전 도 지원을 하는 것 같습니다.\n설치 방법 해당 사이트에서 다운로드 후 설치하시면 됩니다.\n사용방법 기본적인 사용방법은 설치 후 F1로 화면 선택 또는 영역 지정 후 화면에서 더블 클릭 후 F3을 눌러 출력하면 됩니다.\n단축키를 변경 할 수도 있으며, 위를 이용하면 다양한 용도로 사용 할 수 있을 것이라 생각됩니다.\n제 경우 자주 사용하는 용도로는 변수 참조용 또는 퍼블리싱 디자인 또는 유용한 디자인을 참조할 때 자주 쓰는 것 같습니다.\n이외에도 잘 활용하면 여러모로 쾌적한 이용할 수 있습니다. 그 중 자주 사용하는 기본 단축키입니다.\n화면 캡쳐: F1 후 영역 더블클릭 또는 클릭 후 드레그 하여 화면 지정 후 더블클릭 화면 불러오기: F1 저장 후 F3 캡쳐 화면 이동: F3으로 불러오 화면에서 마우스 좌클릭 후 이동 캡쳐 화면 이동: F3으로 불러오 화면에서 마우스 휠 조정 캡쳐 화면 색상 확인: F3으로 불러온 화면에서 Alt키를 누른 후 원하는 색상에서 C버튼 클릭(복사됨) 캡쳐 화면 투명도 조절: F3으로 불러온 화면에서 Ctrl키를 누른 후 마우스 휠 조정 캡쳐 화면 주석 추가: F3으로 불러온 화면에서 Annotation 선택 후 그림도구 사용 ","permalink":"https://haservi.github.io/posts/tools/how-to-capture/","summary":"작업의 효율을 높이기 위해 기존 화면에서 필요한 정보를 잠시 동안 캡쳐하는 방법이 있습니다.\n캡쳐프로그램은 정말 다양하게 존재하는데요. 예를 들어 알캡쳐, picpic, 윈도우 기본 내장 캡쳐, pureRef, snipaste 등 많이 있습니다.\n저 같은 경우 포스팅 할 때 화면캡쳐 용도로는 picpick을 자주 이용하며, 업무 중 필요한 정보를 캡쳐 할 때는 snipaste를 사용합니다.\npicpick의 경우는 워낙 잘 알려져 있기 때문에 snipaste에 대해 알아보겠습니다.\nSnipaste (download link) Snipaste는 특정 화면을 지정하여 캡쳐하여 화면에 띄워놓을 수 있습니다.","title":"화면 캡쳐 프로그램 추천"},{"content":"Windows WSL Ubuntu 커스텀 하기 Window에서는 WSL(Windows Subsystem for Linux)를 제공합니다.\n예전엔 가상환경(VM)에 리눅스를 올렸다면 지금은 손쉽게 리눅스 커널을 WSL로 접근할 수 있게 됐습니다.\n그렇기 때문에 웹개발을 한다면 Window에서 개발하여 WSL에 배포 테스트를 손쉽게? 할 수 있는 환경을 구축 할 수 있습니다. 예를 들어 웹의 경우 Backend, Frontend, DB 같은 환경을 Docker로 설정하여 WSL에 올린 뒤 바로 배포가 성공했다면 이러한 설정을 그대로 AWS나 Azure에 적용할 수 있습니다.\n해당 글은 단지 커스텀에 대한 이야기이지만 추후 위와 같은 방법으로 배포테스트도 한 번 다뤄볼 생각입니다.\n먼저 이 글대로 설정을 마칠 경우 아래와 같은 터미널을 얻을 수 있습니다. 😮\n설치 방법 1. Ubuntu 설치 Window Store에서 Ubuntu를 설치합니다. 2. zsh 설치 먼저 ubuntu 업데이트를 진행합니다. 1 2 sudo apt-get install sudo apt-get update zsh를 기본 셸로 설정합니다. 1 sudo chsh -s $(which zsh) 실행 시 zsh를 실행되도록 지정합니다. 1 sh -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026#34; 3. Meslo Nerd Font 설치 해당 폰트를 사용하지 않으면 powerlevel10k 테마의 아이콘이 표시되지 않습니다.\n아래 링크를 통해 MesloLGS NF 폰트를 다운로드 받아주세요.\nromkatv/powerlevel10k 다운받은 폰트를 Ubuntu에서 폰트를 변경합니다. 상단에서 마우스 우클릭 후 속성을 누른 뒤 폰트를 변경 할 수 있습니다. 4. powerlever10k 설치 zsh를 설치하면 oh-my-zsh라는 폴더가 생깁니다. 해당 폴더에 아래의 테마를 설치합니다. 1 git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k 설치 후 편집기를 이용하여 테마를 변경합니다. 1 vim ~/.zshrc 기존 테마인 ZSH_THEME=\u0026ldquo;robbyrussell\u0026quot;를 ZSH_THEME=\u0026ldquo;powerlevel10k/powerlevel10k\u0026rdquo; 로 변경합니다.(i를 누르면 편집이 가능하며, 수정이 완료된 뒤 ESC를 누르고 :wq 입력) 1 ZSH_THEME=\u0026#34;powerlevel10k/powerlevel10k\u0026#34; 적용을 하셨다면 해당 창을 종료 후 다시 시작하면 아래와 같이 나오게 됩니다.\n(만약 나오지 않은 경우 명령어 source ~/.zshrc 입력) 여기서 본인의 스타일에 맞게 ()안의 답을 선택하면 됩니다. 만약 설정을 잘못하셨거나 바꾸고 싶다면 아래의 커맨드를 입력하시면 됩니다.\n1 p10k configure 5. 폴더 아이콘 테마 변경 해당 테마를 변경하기 위해서는 ruby를 설치하여 colorls를 설치해야 합니다. 1 sudo apt-get install ruby-full colorls를 설치합니다.(만약 아래의 명령어가 안되거나 우분투 20.04 이상 버전인 경우는 sudo apt install gcc make 커맨드 입력 후 다시 설치하시면 됩니다.) 1 sudo gem install colorls 설치가 완료됐으면 ~/.zshrc 가장 하단에 아래 코드를 추가합니다. 1 2 source $(dirname $(gem which colorls))/tab_complete.sh alias ls=colorls 6. fzf 설치 fzf는 zsh의 확장팩? 같은 느낌입니다. 일단 속도가 매우 빠릅니다.(golang??)\n터미널에서 파일검색, 명령 기록, 프로세스, 호스트 이름, 책갈피 등 다양한 기능이 있습니다.\n몇가지 자주쓰는 명령어로\nctrl + r 커맨드에서 사용한 명령어 history 리스트 출력 ctrl + t 해당 폴더의 디렉토리 또는 파일 검색 vim $(fzf) 해당 폴더 안의 검색된 파일 열기 cd 스페이스 ctrl + t 검색 후 폴더 이동 이것 외에도 fzf내에서 플러그인을 설치하여 탐색기처럼 이용할 수도 있고, 프로세스 kill 등 다양한 방법이 있는데 저도 아직 제대로 활용은 못하는 것 같습니다\u0026hellip;\n이와 관련된 링크로 대체하겠습니다. 😓\n윈도우 터미널 테마 변경 WSL를 설치하면 store에 있는 윈도우 터미널도 WSL을 선택할 수 있습니다. 이와 관련하여 테마를 설정할 수 있습니다.\n1. 터미널 색상 변경 기본적으로 터미널의 색을 바꾸고 싶다면 위와 같이 설정에 들어가서 json 파일 선택 후 defaults 제이슨 값에\n1 2 3 4 \u0026#34;defaults\u0026#34;: { // color theme \u0026#34;colorScheme\u0026#34;: \u0026#34;Campbell\u0026#34; }, 해당 테마이름을 지정하고, profiles제이슨 항목 안에\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026#34;schemes\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Campbell\u0026#34;, \u0026#34;cursorColor\u0026#34;: \u0026#34;#FFFFFF\u0026#34;, \u0026#34;selectionBackground\u0026#34;: \u0026#34;#FFFFFF\u0026#34;, \u0026#34;background\u0026#34;: \u0026#34;#0C0C0C\u0026#34;, \u0026#34;foreground\u0026#34;: \u0026#34;#CCCCCC\u0026#34;, \u0026#34;black\u0026#34;: \u0026#34;#0C0C0C\u0026#34;, \u0026#34;blue\u0026#34;: \u0026#34;#4b6ed6\u0026#34;, \u0026#34;cyan\u0026#34;: \u0026#34;#3A96DD\u0026#34;, \u0026#34;green\u0026#34;: \u0026#34;#C50F1F\u0026#34;, \u0026#34;purple\u0026#34;: \u0026#34;#881798\u0026#34;, \u0026#34;red\u0026#34;: \u0026#34;#C50F1F\u0026#34;, \u0026#34;white\u0026#34;: \u0026#34;#CCCCCC\u0026#34;, \u0026#34;yellow\u0026#34;: \u0026#34;#C19C00\u0026#34;, \u0026#34;brightBlack\u0026#34;: \u0026#34;#767676\u0026#34;, \u0026#34;brightBlue\u0026#34;: \u0026#34;#3B78FF\u0026#34;, \u0026#34;brightCyan\u0026#34;: \u0026#34;#61D6D6\u0026#34;, \u0026#34;brightGreen\u0026#34;: \u0026#34;#16C60C\u0026#34;, \u0026#34;brightPurple\u0026#34;: \u0026#34;#B4009E\u0026#34;, \u0026#34;brightRed\u0026#34;: \u0026#34;#E74856\u0026#34;, \u0026#34;brightWhite\u0026#34;: \u0026#34;#F2F2F2\u0026#34;, \u0026#34;brightYellow\u0026#34;: \u0026#34;#F9F1A5\u0026#34; } ], 이렇게 지정해주면 됩니다. 공식 사이트(링크) 에서도 참조하면 좋을 것 같습니다.\n위와 같은 방법으로 다른 테마를 적용하고 싶다면, https://windowsterminalthemes.dev/ 에서 원하는 테마를 복사하셔도 됩니다.\n2. 터미널 배경 변경 터미널 배경을 변경하고 싶으면 아래와 같이 설정해주시면 됩니다.\n1 2 3 4 5 \u0026#34;defaults\u0026#34;: { \u0026#34;acrylicOpacity\u0026#34; : 0.4, \u0026#34;backgroundImage\u0026#34;: \u0026#34;D:/ProgramFiles/Images/cool-wallpaper-preview-1.jpg\u0026#34;, \u0026#34;backgroundImageOpacity\u0026#34;: 0.4 }, 3. 글꼴 변경 해당 글꼴을 넣어줘야 powerlink10k에서 아이콘을 볼 수 있습니다.\n1 2 3 4 \u0026#34;defaults\u0026#34;: { \u0026#34;fontFace\u0026#34; : \u0026#34;MesloLGS NF\u0026#34;, \u0026#34;fontSize\u0026#34; : 13 }, 탐색기에 WSL 연결하기 탐색기 주소창에 아래의 주소값을 입력합니다. 1 \\\\wsl$ Unbutu 폴더에서 우측마우스 클릭 후 네트워크 드라이브 연결을 선택한다. 연결 후 원하는 이름으로 변경하면 탐색기에서 WSL에 접근이 가능합니다. 에러 관련 아래와 같은 에러가 발생하면 1 bash: ll: command not found 이렇게 명령어를 입력하면 해결됩니다. 1 2 echo \u0026#34;alias ll=\u0026#39;ls -lGaf\u0026#39;\u0026#34; \u0026gt;\u0026gt; ~/.bash_profile source ~/.bash_profile 이상으로 윈도우에서 WSL 우분투 터미널 꾸미는 방법에 대해 알아보았습니다.\nReference Setting up Windows Terminal, WSL and Oh-my-Zsh - Ivo\u0026rsquo;s Blog! https://snowdeer.github.io/mac-os/2018/11/04/how-to-use-fzf/ fzf Github WSL 동작 원리 FZF 터미널 사용 방법 ","permalink":"https://haservi.github.io/posts/linux/used-zsh-powerline10/","summary":"Windows WSL Ubuntu 커스텀 하기 Window에서는 WSL(Windows Subsystem for Linux)를 제공합니다.\n예전엔 가상환경(VM)에 리눅스를 올렸다면 지금은 손쉽게 리눅스 커널을 WSL로 접근할 수 있게 됐습니다.\n그렇기 때문에 웹개발을 한다면 Window에서 개발하여 WSL에 배포 테스트를 손쉽게? 할 수 있는 환경을 구축 할 수 있습니다. 예를 들어 웹의 경우 Backend, Frontend, DB 같은 환경을 Docker로 설정하여 WSL에 올린 뒤 바로 배포가 성공했다면 이러한 설정을 그대로 AWS나 Azure에 적용할 수 있습니다.\n해당 글은 단지 커스텀에 대한 이야기이지만 추후 위와 같은 방법으로 배포테스트도 한 번 다뤄볼 생각입니다.","title":"윈도우 WSL2 Ubuntu 터미널 꾸미기"},{"content":"ddl-auto 란 JPA에서는 기본적으로 Entity에 테이블을 매핑하면 쿼리를 사용하지 않고 값을 가져올 수 있습니다.\n설정 옵션으로\n1 2 3 jpa: hibernate: ddl-auto: create #create-drop, update, validate, none 각각의 옵션을 봐보면 아래와 같습니다.\ncreate : SessionFactory 시작시 스키마를 삭제하고 다시 생성 create-drop : SessionFactory 종료 시 스키마를 삭제 update : SessionFactory 연결된 DB와 비교하여 추가된 항목은 추가 만약 같은 변수명이면 오류발생 validate : SessionFactory 시작시 객체구성과 스키마가 다르다면 예외 발생 none: 아무것도 안함 실제 서비스 배포시에는 create, create-drop, update 와 같은 옵션을 사용하면 안되지만 개발 초기 테스트시에는 유용하게 사용할 수 있습니다.\n샘플데이터 추가 방법 그렇지만 데이터 테이블만 생기고 데이터가 없으니 오히려 테스트하기 불편한 점이 있습니다.\n그렇기에 찾아보니 역시 당연하게도.. resources 폴더에 import.sql 파일을 추가하면 hibernate에서 알아서 해당 더미데이터 쿼리를 찾아 실해시켜줍니다.\n만약 특정 파일을 지정하고 싶다면 아래와 같이\n1 2 3 4 5 6 7 8 jpa: properties: hibernate: hbm2ddl: import_files: classpath:db/data.sql # DB 파일 명시적으로 선택 import_files_sql_extractor: org.hibernate.tool.hbm2ddl.MultipleLinesSqlCommandExtractor # 멀티 라인 입력 가능하도록 connection: charSet: UTF-8 # 인코딩 설정 파일명을 명시주면 create에 자동으로 해당 데이터를 insert 할 수 있습니다.\n예제 만약 아래와 같이 user 테이블이 있다면..\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 import java.time.LocalDateTime; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.Table; import lombok.AccessLevel; import lombok.Builder; import lombok.Getter; import lombok.NoArgsConstructor; import org.hibernate.annotations.ColumnDefault; import org.hibernate.annotations.DynamicUpdate; @NoArgsConstructor(access = AccessLevel.PROTECTED) @Getter @Entity @DynamicUpdate @Table(name = \u0026#34;user\u0026#34;) public class UserEntity { @Id @GeneratedValue(strategy= GenerationType.IDENTITY) @Column(nullable = false, updatable = false) private Long userSno; @Column(length = 20, nullable = false, unique = true) private String userId; @Column(length = 20) private String userName; @Column(length = 20, nullable = false) private String password; @Column(length = 30) private String email; @Column(nullable = false, updatable = false, insertable = false, columnDefinition = \u0026#34;TIMESTAMP DEFAULT CURRENT_TIMESTAMP\u0026#34;) private LocalDateTime createDt; @Column(nullable = false, updatable = false, insertable = false) @ColumnDefault(\u0026#34;0\u0026#34;) private int useYn; @Builder public UserEntity(Long userSno, String userId, String userName, String password, String email) { this.userSno = userSno; this.userId = userId; this.userName = userName; this.password = password; this.email = email; } } import.sql파일 또는 지정한 sql파일에 아래와 같이 코드를 추가해주면 빌드 시 자동적으로 데이터를 넣을 수 있습니다.\n1 2 insert into `user` (`email`, `password`, `user_id`, `user_name`) values (\u0026#39;admin@admin.com\u0026#39;, \u0026#39;$2a$10$dyiw3YfbmBkHlUdbgWhsYesqniOsXo71KBzF75le5.YtS/rsrsM22\u0026#39;, \u0026#39;admin\u0026#39;, \u0026#39;관리자\u0026#39;); insert into `user` (`email`, `password`, `user_id`, `user_name`) values (\u0026#39;test@test.com\u0026#39;, \u0026#39;$2a$10$PMc5QFOUViVsGmsNMQqUzOuQG2rZ2wUJjSTRGFkBo9jZR/CSnQ03K\u0026#39;, \u0026#39;test\u0026#39;, \u0026#39;테스트\u0026#39;); 주의할 점은 실제 배포시에는 꼭 ddl-auto를 none으로 해야 합니다.\nddl-auto의 경우 초기 DB 설정 및 간단한 테스트에서만 쓰는게 좋습니다.\n","permalink":"https://haservi.github.io/posts/spring/hibernate-ddl-auto/","summary":"ddl-auto 란 JPA에서는 기본적으로 Entity에 테이블을 매핑하면 쿼리를 사용하지 않고 값을 가져올 수 있습니다.\n설정 옵션으로\n1 2 3 jpa: hibernate: ddl-auto: create #create-drop, update, validate, none 각각의 옵션을 봐보면 아래와 같습니다.\ncreate : SessionFactory 시작시 스키마를 삭제하고 다시 생성 create-drop : SessionFactory 종료 시 스키마를 삭제 update : SessionFactory 연결된 DB와 비교하여 추가된 항목은 추가 만약 같은 변수명이면 오류발생 validate : SessionFactory 시작시 객체구성과 스키마가 다르다면 예외 발생 none: 아무것도 안함 실제 서비스 배포시에는 create, create-drop, update 와 같은 옵션을 사용하면 안되지만 개발 초기 테스트시에는 유용하게 사용할 수 있습니다.","title":"JPA ddl-auto 설정과 더미데이터 생성 방법"},{"content":"간단하게 무거운 프로그램을 이용하지 않고 영상을 gif로 만드는 방법입니다.\n윈도우 - https://www.screentogif.com/ Mac - https://apps.apple.com/us/app/giphy-capture-the-gif-maker/id668208984?mt=12 위 프로그램을 다운로드 받아서 설치하면 됩니다.\n설치 방법(Window) https://www.screentogif.com/ 사이트에 접속하셔서 다운로드 합니다. 다운로드 후 설치 합니다. 설치가 완료되면 실행합니다.\n위와 같은 화면에서 선택 영역을 지정(예시: 메모장)하고 녹화를 누르면 아래와 같이 나타납니다.\n여기서 그냥 녹화를 누른뒤 진행하면 됩니다. 녹화를 마치고 정지를 누르시면 아래와 같은 화면이 나타납니다.\n저 같은 경우 초당 30프레임으로 설정하여서 5초짜리 영상에 대략 150프레임의 스크린샷이 찍혔습니다. 많약 더 부드럽게 만드시고 싶다면 프레임을 올리면 됩니다. 그리고 각각의 프레임들은 모두 제거가 가능하기 때문에 쓸모없는 동작들의 프레임을 제거 할 수 있습니다. 편집 작업이 끝나고 상단의 파일의 저장 버튼을 누르시면 됩니다.\n최종적으로 아래와 같이 애니메이션 화면을 볼 수 있습니다.\n해당 프로그램을 이용하여 처음 구동화면이나 미리 결과물을 보여주면 직관적으로 결과물을 볼 수 있습니다.\n","permalink":"https://haservi.github.io/posts/tools/how-to-create-gif/","summary":"간단하게 무거운 프로그램을 이용하지 않고 영상을 gif로 만드는 방법입니다.\n윈도우 - https://www.screentogif.com/ Mac - https://apps.apple.com/us/app/giphy-capture-the-gif-maker/id668208984?mt=12 위 프로그램을 다운로드 받아서 설치하면 됩니다.\n설치 방법(Window) https://www.screentogif.com/ 사이트에 접속하셔서 다운로드 합니다. 다운로드 후 설치 합니다. 설치가 완료되면 실행합니다.\n위와 같은 화면에서 선택 영역을 지정(예시: 메모장)하고 녹화를 누르면 아래와 같이 나타납니다.\n여기서 그냥 녹화를 누른뒤 진행하면 됩니다. 녹화를 마치고 정지를 누르시면 아래와 같은 화면이 나타납니다.\n저 같은 경우 초당 30프레임으로 설정하여서 5초짜리 영상에 대략 150프레임의 스크린샷이 찍혔습니다.","title":"영상을 gif로 만드는 방법"},{"content":"조이스틱 문제 설명 조이스틱으로 알파벳 이름을 완성하세요. 맨 처음엔 A로만 이루어져 있습니다.\nex) 완성해야 하는 이름이 세 글자면 AAA, 네 글자면 AAAA\n조이스틱을 각 방향으로 움직이면 아래와 같습니다.\n1 2 3 4 ▲ - 다음 알파벳 ▼ - 이전 알파벳 (A에서 아래쪽으로 이동하면 Z로) ◀ - 커서를 왼쪽으로 이동 (첫 번째 위치에서 왼쪽으로 이동하면 마지막 문자에 커서) ▶ - 커서를 오른쪽으로 이동 예를 들어 아래의 방법으로 \u0026ldquo;JAZ\u0026quot;를 만들 수 있습니다.\n1 2 3 4 - 첫 번째 위치에서 조이스틱을 위로 9번 조작하여 J를 완성합니다. - 조이스틱을 왼쪽으로 1번 조작하여 커서를 마지막 문자 위치로 이동시킵니다. - 마지막 위치에서 조이스틱을 아래로 1번 조작하여 Z를 완성합니다. 따라서 11번 이동시켜 \u0026#34;JAZ\u0026#34;를 만들 수 있고, 이때가 최소 이동입니다. 만들고자 하는 이름 name이 매개변수로 주어질 때, 이름에 대해 조이스틱 조작 횟수의 최솟값을 return 하도록 solution 함수를 만드세요.\n제한 사항 name은 알파벳 대문자로만 이루어져 있습니다. name의 길이는 1 이상 20 이하입니다. 입출력 예 name return \u0026ldquo;JEROEN\u0026rdquo; 56 \u0026ldquo;JAN\u0026rdquo; 23 출처 ※ 공지 - 2019년 2월 28일 테스트케이스가 추가되었습니다.\n문제 풀이 리뷰 기본적으로 모든 알파벳 위치에서의 최소거리를 구하고, 바로앞의 A가 있다면 해당 값을 제외한 뒤에 거리를 정의해야한다.\n또한, 해당 인덱스의 위치에서 정방향과 역방향에서 둘 중의 거리가 짧은 곳을 구한 뒤 바로앞의 A를 제외한 총이동거리를 더하는 부분이 중요하다.\n그렇게 모든 알파벳의 좌우 이동 최소거리 중 가장작은 값을 상하 알파벳 이동값과 더하여 주면된다.\nSource code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 public int solution(String name) { int answer = 0; int nameLength = name.length(); int changeAlpabatCount = 0; for (int i = 0; i \u0026lt; nameLength; i++) { // 알파벳 변경 시 최소값 선정 후 화살표 위아래 변경 횟수 추가 changeAlpabatCount += Math.min(name.charAt(i) - \u0026#39;A\u0026#39;, \u0026#39;Z\u0026#39; - name.charAt(i) + 1); } // 알파벳의 정방향 최대 이동거리를 최소거리로 지정 int minMove = nameLength - 1; for (int i = 0; i \u0026lt; nameLength; i++) { int next = i + 1; int nextCountA = 0; while (next \u0026lt; nameLength \u0026amp;\u0026amp; name.charAt(next) == \u0026#39;A\u0026#39;) { next++; nextCountA++; } // 0번쨰 인덱스에서 앞의 A를 제외하고 이동한 거리 int moveWithoutA = name.length() - nextCountA - 1; // System.out.println(\u0026#34;movewithA:\u0026#34; + moveWithoutA); // 처음부터 i번째 까지 왔다가 돌아가는 방식과 뒤에서 출발하여 i번째 까지 오는 방식중 작은 값 선택 int min = Math.min(i, name.length() - next); // 알파벳을 순회하며 작은 값을 선택 minMove = Math.min(minMove, moveWithoutA + min); // System.out.println(i + \u0026#34;번째값의 평균 이동 거리는 \u0026#34; + (moveWithoutA + min) + \u0026#34;이다.\u0026#34;); } // System.out.println(\u0026#34;총 알파벳 변경 회수는 \u0026#34; + changeAlpabatCount + \u0026#34;이며, 최소이동 거리는 \u0026#34; + minMove + \u0026#34;이다.\u0026#34;); answer = (changeAlpabatCount + minMove); return answer; } ","permalink":"https://haservi.github.io/posts/algorithms/programmers/level2/03-joystick/","summary":"조이스틱 문제 설명 조이스틱으로 알파벳 이름을 완성하세요. 맨 처음엔 A로만 이루어져 있습니다.\nex) 완성해야 하는 이름이 세 글자면 AAA, 네 글자면 AAAA\n조이스틱을 각 방향으로 움직이면 아래와 같습니다.\n1 2 3 4 ▲ - 다음 알파벳 ▼ - 이전 알파벳 (A에서 아래쪽으로 이동하면 Z로) ◀ - 커서를 왼쪽으로 이동 (첫 번째 위치에서 왼쪽으로 이동하면 마지막 문자에 커서) ▶ - 커서를 오른쪽으로 이동 예를 들어 아래의 방법으로 \u0026ldquo;JAZ\u0026quot;를 만들 수 있습니다.","title":"[프로그래머스]조이스틱"},{"content":"다리를 지나는 트럭 문제 설명 트럭 여러 대가 강을 가로지르는 일차선 다리를 정해진 순으로 건너려 합니다.\n모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 알아내야 합니다.\n다리에는 트럭이 최대 bridge_length대 올라갈 수 있으며, 다리는 weight 이하까지의 무게를 견딜 수 있습니다.\n단, 다리에 완전히 오르지 않은 트럭의 무게는 무시합니다.\n예를 들어, 트럭 2대가 올라갈 수 있고 무게를 10kg까지 견디는 다리가 있습니다. 무게가 [7, 4, 5, 6]kg인 트럭이 순서대로 최단 시간 안에 다리를 건너려면 다음과 같이 건너야 합니다.\n경과 시간 다리를 지난 트럭 다리를 건너는 트럭 대기 트럭 0 [] [] [7,4,5,6] 1~2 [] [7] [4,5,6] 3 [7] [4] [5,6] 4 [7] [4,5] [6] 5 [7,4] [5] [6] 6~7 [7,4,5] [6] [] 8 [7,4,5,6] [] [] 따라서, 모든 트럭이 다리를 지나려면 최소 8초가 걸립니다.\nsolution 함수의 매개변수로 다리에 올라갈 수 있는 트럭 수 bridge_length, 다리가 견딜 수 있는 무게 weight, 트럭 별 무게 truck_weights가 주어집니다.\n이때 모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 return 하도록 solution 함수를 완성하세요.\n제한 조건 bridge_length는 1 이상 10,000 이하입니다. weight는 1 이상 10,000 이하입니다. truck_weights의 길이는 1 이상 10,000 이하입니다. 모든 트럭의 무게는 1 이상 weight 이하입니다. 입출력 예 bridge_length weight truck_weights return 2 10 [7,4,5,6] 8 100 100 [10] 101 100 100 [10,10,10,10,10,10,10,10,10,10] 110 문제 풀이 리뷰 Java Source Code 트럭이 모두 다리를 건너가야 하기 때문에 트럭의 횟수만큼 순회한다. 다리를 지날 때는 트럭큐를 이용하며, 시간을 계속 추가한다. 마지막 트럭의 경우 지나갈 때 다리의 길이만큼 시간을 소모하기 때문에 처음에 다리의 길이만큼 값을 더해주었다. ","permalink":"https://haservi.github.io/posts/algorithms/programmers/level2/02-truck-crossing-the-bridge/","summary":"다리를 지나는 트럭 문제 설명 트럭 여러 대가 강을 가로지르는 일차선 다리를 정해진 순으로 건너려 합니다.\n모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 알아내야 합니다.\n다리에는 트럭이 최대 bridge_length대 올라갈 수 있으며, 다리는 weight 이하까지의 무게를 견딜 수 있습니다.\n단, 다리에 완전히 오르지 않은 트럭의 무게는 무시합니다.\n예를 들어, 트럭 2대가 올라갈 수 있고 무게를 10kg까지 견디는 다리가 있습니다. 무게가 [7, 4, 5, 6]kg인 트럭이 순서대로 최단 시간 안에 다리를 건너려면 다음과 같이 건너야 합니다.","title":"[프로그래머스]다리를 지나는 트럭"},{"content":"위장 문제 설명 스파이들은 매일 다른 옷을 조합하여 입어 자신을 위장합니다.\n예를 들어 스파이가 가진 옷이 아래와 같고 오늘 스파이가 동그란 안경, 긴 코트, 파란색 티셔츠를 입었다면 다음날은 청바지를 추가로 입거나 동그란 안경 대신 검정 선글라스를 착용하거나 해야 합니다.\n종류 이름 얼굴 동그란 안경, 검정 선글라스 상의 파란색 티셔츠 하의 청바지 겉옷 긴 코트 스파이가 가진 의상들이 담긴 2차원 배열 clothes가 주어질 때 서로 다른 옷의 조합의 수를 return 하도록 solution 함수를 작성해주세요.\n제한사항 clothes의 각 행은 [의상의 이름, 의상의 종류]로 이루어져 있습니다. 스파이가 가진 의상의 수는 1개 이상 30개 이하입니다. 같은 이름을 가진 의상은 존재하지 않습니다. clothes의 모든 원소는 문자열로 이루어져 있습니다. 모든 문자열의 길이는 1 이상 20 이하인 자연수이고 알파벳 소문자 또는 \u0026lsquo;_\u0026rsquo; 로만 이루어져 있습니다. 스파이는 하루에 최소 한 개의 의상은 입습니다. 입출력 예 clothes return [[\u0026ldquo;yellowhat\u0026rdquo;, \u0026ldquo;headgear\u0026rdquo;], [\u0026ldquo;bluesunglasses\u0026rdquo;, \u0026ldquo;eyewear\u0026rdquo;], [\u0026ldquo;green_turban\u0026rdquo;, \u0026ldquo;headgear\u0026rdquo;]] 5 [[\u0026ldquo;crowmask\u0026rdquo;, \u0026ldquo;face\u0026rdquo;], [\u0026ldquo;bluesunglasses\u0026rdquo;, \u0026ldquo;face\u0026rdquo;], [\u0026ldquo;smoky_makeup\u0026rdquo;, \u0026ldquo;face\u0026rdquo;]] 3 입출력 예 설명 예제 #1\nheadgear에 해당하는 의상이 yellow_hat, green_turban이고 eyewear에 해당하는 의상이 blue_sunglasses이므로 아래와 같이 5개의 조합이 가능합니다.\n1 2 3 4 5 1. yellow_hat 2. blue_sunglasses 3. green_turban 4. yellow_hat + blue_sunglasses 5. green_turban + blue_sunglasses 예제 #2 face에 해당하는 의상이 crow_mask, blue_sunglasses, smoky_makeup이므로 아래와 같이 3개의 조합이 가능합니다.\n1 2 3 1. crow_mask 2. blue_sunglasses 3. smoky_makeup 문제 풀이 문제 풀이 리뷰 확률 문제이다. 예를 들어 정육각형 주사위A 주사위B 2개로 나오는 경우의 수는 6 * 6으로 36개이다. 그렇지만 주사위 객체 1개도 경우의 수로 인정하게 되면 (7 x 7) - 1로 48개 이다. 여기서 -1은 주사위가 없는 경우라고 생각할 수 있다. 해당 문제도 같은 방식으로 이해하면 각 옷들은 주사위이고 옷의 개수는 주사위의 번호 개수이다. 예를 들어 옷의 종류가 3개이며, 각각 2벌씩이면 ((2 + 1) * (2 + 1) * (2 + 1)) - 1 = 26 이다. 해당 문제의 풀이 방법은 어느 정도 알았지만, hashMap의 확장함수로 getOrDefault가 있다는 것을 알게됐다. getOrDefault의 두 번째 매개변수인 defaultValue는 지정된 키로 매핑된 값이 없으면 반환되는 값이다. Source code Java (Source code) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public int solution(String[][] clothes) { int answer = 1; int clothCount = clothes.length; HashMap\u0026lt;String, Integer\u0026gt; hashMap = new HashMap\u0026lt;String, Integer\u0026gt;(); for (int i = 0; i \u0026lt; clothCount; i++) { int clothSum = hashMap.getOrDefault(clothes[i][1], 0) + 1; hashMap.put(clothes[i][1], clothSum); } for (int count : hashMap.values()) { answer = answer * (count + 1); } answer = answer - 1; return answer; } ","permalink":"https://haservi.github.io/posts/algorithms/programmers/level2/01-camouflage/","summary":"위장 문제 설명 스파이들은 매일 다른 옷을 조합하여 입어 자신을 위장합니다.\n예를 들어 스파이가 가진 옷이 아래와 같고 오늘 스파이가 동그란 안경, 긴 코트, 파란색 티셔츠를 입었다면 다음날은 청바지를 추가로 입거나 동그란 안경 대신 검정 선글라스를 착용하거나 해야 합니다.\n종류 이름 얼굴 동그란 안경, 검정 선글라스 상의 파란색 티셔츠 하의 청바지 겉옷 긴 코트 스파이가 가진 의상들이 담긴 2차원 배열 clothes가 주어질 때 서로 다른 옷의 조합의 수를 return 하도록 solution 함수를 작성해주세요.","title":"[프로그래머스]위장"},{"content":"하샤드 수 문제 설명 양의 정수 x가 하샤드 수이려면 x의 자릿수의 합으로 x가 나누어져야 합니다.\n예를 들어 18의 자릿수 합은 1+8=9이고, 18은 9로 나누어 떨어지므로 18은 하샤드 수입니다.\n자연수 x를 입력받아 x가 하샤드 수인지 아닌지 검사하는 함수, solution을 완성해주세요.\n제한 조건 x는 1 이상, 10000 이하인 정수입니다. 입출력 예 arr return 10 true 12 true 11 false 13 false 입출력 예 설명 입출력 예 #1\n10의 모든 자릿수의 합은 1입니다. 10은 1로 나누어 떨어지므로 10은 하샤드 수입니다.\n입출력 예 #2\n12의 모든 자릿수의 합은 3입니다. 12는 3으로 나누어 떨어지므로 12는 하샤드 수입니다.\n입출력 예 #3\n11의 모든 자릿수의 합은 2입니다. 11은 2로 나누어 떨어지지 않으므로 11는 하샤드 수가 아닙니다.\n입출력 예 #4\n13의 모든 자릿수의 합은 4입니다. 13은 4로 나누어 떨어지지 않으므로 13은 하샤드 수가 아닙니다.\n문제 풀이 리뷰 [Java](https://github.com/haservi/study-algorithm/blob/main/programmers/Level1/lv1_47_%ED%95%98%EC%83%A4%EB%93%9C_%EC%88%98/Solution.java 각 자리수의 합을 구한 뒤 나머지가 0인 경우 true를 반환한다. 나의 풀이(Source code) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public boolean solution(int x) { int sum = 0; int num = x; // 자릿수의 합 while (num != 0) { sum += num % 10; num /= 10; } // 나머지가 0이면 하샤드 수라고 판단 if (x % sum == 0) return true; else return false; } ","permalink":"https://haservi.github.io/posts/algorithms/programmers/level1/04-algo-hasshadsu/","summary":"하샤드 수 문제 설명 양의 정수 x가 하샤드 수이려면 x의 자릿수의 합으로 x가 나누어져야 합니다.\n예를 들어 18의 자릿수 합은 1+8=9이고, 18은 9로 나누어 떨어지므로 18은 하샤드 수입니다.\n자연수 x를 입력받아 x가 하샤드 수인지 아닌지 검사하는 함수, solution을 완성해주세요.\n제한 조건 x는 1 이상, 10000 이하인 정수입니다. 입출력 예 arr return 10 true 12 true 11 false 13 false 입출력 예 설명 입출력 예 #1\n10의 모든 자릿수의 합은 1입니다. 10은 1로 나누어 떨어지므로 10은 하샤드 수입니다.","title":"[프로그래머스]하샤드 수"},{"content":"콜라츠 추측 문제 설명 1937년 Collatz란 사람에 의해 제기된 이 추측은, 주어진 수가 1이 될때까지 다음 작업을 반복하면, 모든 수를 1로 만들 수 있다는 추측입니다. 작업은 다음과 같습니다.\n1 2 3 1-1. 입력된 수가 짝수라면 2로 나눕니다. 1-2. 입력된 수가 홀수라면 3을 곱하고 1을 더합니다. 2. 결과로 나온 수에 같은 작업을 1이 될 때까지 반복합니다. 예를 들어, 입력된 수가 6이라면 6→3→10→5→16→8→4→2→1 이 되어 총 8번 만에 1이 됩니다.\n위 작업을 몇 번이나 반복해야하는지 반환하는 함수, solution을 완성해 주세요.\n단, 작업을 500번을 반복해도 1이 되지 않는다면 –1을 반환해 주세요.\n제한 사항 입력된 수, num은 1 이상 8000000 미만인 정수입니다. 입출력 예 n result 6 8 16 4 626331 -1 입출력 예 설명 입출력 예 #1\n문제의 설명과 같습니다.\n입출력 예 #2\n16 -\u0026gt; 8 -\u0026gt; 4 -\u0026gt; 2 -\u0026gt; 1 이되어 총 4번만에 1이 됩니다.\n입출력 예 #3\n626331은 500번을 시도해도 1이 되지 못하므로 -1을 리턴해야합니다.\n문제 풀이 문제 풀이 리뷰 반복적으로 돌면서 짝수이면 2로 나누고 홀수이면 해당값에 3을 곱한 후 1을 더해준다. 해당 반복이 500회가 되면 -1을 리턴한다. Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public int solution(long num) { int answer = 0; while (num != 1) { if (num % 2 == 0) { num = num / 2; } else { num = (num * 3) + 1; } answer++; if (answer == 500) { return -1; } } return answer; } ","permalink":"https://haservi.github.io/posts/algorithms/programmers/level1/03-algo-colatz-guess/","summary":"콜라츠 추측 문제 설명 1937년 Collatz란 사람에 의해 제기된 이 추측은, 주어진 수가 1이 될때까지 다음 작업을 반복하면, 모든 수를 1로 만들 수 있다는 추측입니다. 작업은 다음과 같습니다.\n1 2 3 1-1. 입력된 수가 짝수라면 2로 나눕니다. 1-2. 입력된 수가 홀수라면 3을 곱하고 1을 더합니다. 2. 결과로 나온 수에 같은 작업을 1이 될 때까지 반복합니다. 예를 들어, 입력된 수가 6이라면 6→3→10→5→16→8→4→2→1 이 되어 총 8번 만에 1이 됩니다.\n위 작업을 몇 번이나 반복해야하는지 반환하는 함수, solution을 완성해 주세요.","title":"[프로그래머스]콜라츠 추측"},{"content":"직업군 추천하기 문제 설명 개발자가 사용하는 언어와 언어 선호도를 입력하면 그에 맞는 직업군을 추천해주는 알고리즘을 개발하려고 합니다.\n아래 표는 5개 직업군 별로 많이 사용하는 5개 언어에 직업군 언어 점수를 부여한 표입니다.\n점수 SI CONTENTS HARDWARE PORTAL GAME 5 JAVA JAVASCRIPT C JAVA C++ 4 JAVASCRIPT JAVA C++ JAVASCRIPT C# 3 SQL PYTHON PYTHON PYTHON JAVASCRIPT 2 PYTHON SQL JAVA KOTLIN C 1 C# C++ JAVASCRIPT PHP JAVA 예를 들면, SQL의 SI 직업군 언어 점수는 3점이지만 CONTENTS 직업군 언어 점수는 2점입니다.\nSQL의 HARDWARE, PORTAL, GAME 직업군 언어 점수는 0점입니다.\n직업군 언어 점수를 정리한 문자열 배열 table, 개발자가 사용하는 언어를 담은 문자열 배열 languages, 언어 선호도를 담은 정수 배열 preference가 매개변수로 주어집니다.\n개발자가 사용하는 언어의 언어 선호도 x 직업군 언어 점수의 총합이 가장 높은 직업군을 return 하도록 solution 함수를 완성해주세요.\n총합이 같은 직업군이 여러 개일 경우, 이름이 사전 순으로 가장 빠른 직업군을 return 해주세요.\n제한사항 table의 길이 = 5 table의 원소는 \u0026ldquo;직업군 5점언어 4점언어 3점언어 2점언어 1점언어\u0026quot;형식의 문자열입니다. 직업군, 5점언어, 4언어, 3점언어, 2점언어, 1점언어는 하나의 공백으로 구분되어 있습니다. table은 모든 테스트케이스에서 동일합니다. 1 ≤ languages의 길이 ≤ 9 languages의 원소는 \u0026ldquo;JAVA\u0026rdquo;, \u0026ldquo;JAVASCRIPT\u0026rdquo;, \u0026ldquo;C\u0026rdquo;, \u0026ldquo;C++\u0026rdquo; ,\u0026ldquo;C#\u0026rdquo; , \u0026ldquo;SQL\u0026rdquo;, \u0026ldquo;PYTHON\u0026rdquo;, \u0026ldquo;KOTLIN\u0026rdquo;, \u0026ldquo;PHP\u0026rdquo; 중 한 개 이상으로 이루어져 있습니다. languages의 원소는 중복되지 않습니다. preference의 길이 = languages의 길이 1 ≤ preference의 원소 ≤ 10 preference의 i번째 원소는 languages의 i번째 원소의 언어 선호도입니다. return 할 문자열은 \u0026ldquo;SI\u0026rdquo;, \u0026ldquo;CONTENTS\u0026rdquo;, \u0026ldquo;HARDWARE\u0026rdquo;, \u0026ldquo;PORTAL\u0026rdquo;, \u0026ldquo;GAME\u0026rdquo; 중 하나입니다. 입출력 예 table languages preference result [\u0026ldquo;SI JAVA JAVASCRIPT SQL PYTHON C#\u0026rdquo;, \u0026ldquo;CONTENTS JAVASCRIPT JAVA PYTHON SQL C++\u0026rdquo;, \u0026ldquo;HARDWARE C C++ PYTHON JAVA JAVASCRIPT\u0026rdquo;, \u0026ldquo;PORTAL JAVA JAVASCRIPT PYTHON KOTLIN PHP\u0026rdquo;, \u0026ldquo;GAME C++ C# JAVASCRIPT C JAVA\u0026rdquo;] [\u0026ldquo;PYTHON\u0026rdquo;, \u0026ldquo;C++\u0026rdquo;, \u0026ldquo;SQL\u0026rdquo;] [7, 5, 5] \u0026ldquo;HARDWARE\u0026rdquo; [\u0026ldquo;SI JAVA JAVASCRIPT SQL PYTHON C#\u0026rdquo;, \u0026ldquo;CONTENTS JAVASCRIPT JAVA PYTHON SQL C++\u0026rdquo;, \u0026ldquo;HARDWARE C C++ PYTHON JAVA JAVASCRIPT\u0026rdquo;, \u0026ldquo;PORTAL JAVA JAVASCRIPT PYTHON KOTLIN PHP\u0026rdquo;, \u0026ldquo;GAME C++ C# JAVASCRIPT C JAVA\u0026rdquo;] [\u0026ldquo;JAVA\u0026rdquo;, \u0026ldquo;JAVASCRIPT\u0026rdquo;] [7, 5] \u0026ldquo;PORTAL\u0026rdquo; 입출력 예 설명 입출력 예 #1\n각 직업군 별로 점수를 계산해보면 아래와 같습니다.\n아래 사진은 개발자 언어 선호도 나타낸 표입니다.\nPython C++ SQL 선호도 7 5 5 아래 사진은 개발자가 선호하는 언어의 직업군 언어 점수를 나타낸 표입니다.\nSI CONTENTS HARDWARE PORTAL GAME PYTHON 2 3 3 3 0 c++ 0 1 4 0 5 SQL 3 2 0 0 0 직업군별 점수 식 $72 + 50 + 5*3$ $73 + 51 + 5*2$ $73 + 54 + 5*0$ $73 + 50 + 5*0$ $70 + 55 + 5*0$ 점수 총합 29 36 41 21 25 따라서 점수 총합이 41로 가장 높은 \u0026quot;HARDWARE\u0026quot;를 return 해야 합니다.\n입출력 예 #2 각 직업군 별로 점수를 계산해보면 아래와 같습니다.\n아래 사진은 개발자 언어 선호도 나타낸 표입니다.\nJAVA JAVASCRIPT 선호도 7 5 아래 사진은 개발자가 선호하는 언어의 직업군 언어 점수를 나타낸 표입니다.\nSI CONTENTS HARDWARE PORTAL GAME JAVA 5 4 2 5 1 JAVASCRIPT 4 5 1 4 3 직업군별 점수 식 $75 + 54$ $74 + 55$ $72 + 51$ $75 + 54$ $71 + 53$ 점수 총합 55 53 19 55 22 점수 총합이 55로 가장 높은 직업군은 \u0026ldquo;SI\u0026rdquo; 와 \u0026ldquo;PORTAL\u0026quot;입니다. 따라서 사전 순으로 먼저 오는 \u0026quot;PORTAL\u0026quot;을 return 해야 합니다.\n문제 풀이 리뷰 Java TreeMap에 language 값에 맞는 table의 배열을 맞춘 후 preference 값을 더하였다. 이렇게 하면 자동적으로 언어 별 점수의 합이 정렬된다. 이 후 점수 가 큰 순서로 내림차순 한 뒤 첫번째 값을 리턴하였다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 import java.util.*; class Solution { public static void main(String[] args) { Solution solution = new Solution(); String[] table = { \u0026#34;BI JAVA JAVASCRIPT SQL PYTHON C#\u0026#34;, \u0026#34;AONTENTS JAVASCRIPT JAVA PYTHON SQL C++\u0026#34;, \u0026#34;HARDWARE C C++ PYTHON JAVA JAVASCRIPT\u0026#34;, \u0026#34;AORTAL JAVA JAVASCRIPT PYTHON KOTLIN PHP\u0026#34;, \u0026#34;GAME C++ C# JAVASCRIPT C JAVA\u0026#34; }; String[] languages = { \u0026#34;JAVA\u0026#34;, \u0026#34;JAVASCRIPT\u0026#34; }; int[] preference = { 7, 5 }; String result = solution.solution(table, languages, preference); System.out.println(\u0026#34;결과 : \u0026#34; + result); } public String solution(String[] table, String[] languages, int[] preference) { Map\u0026lt;String, Integer\u0026gt; jobResultMap = new TreeMap\u0026lt;String, Integer\u0026gt;(); // ValueComparator bvc = new ValueComparator(jobResultMap); // TreeMap\u0026lt;String, Integer\u0026gt; sortedMap = new TreeMap\u0026lt;String, Integer\u0026gt;(bvc); int tableCount = table.length; for (int i = 0; i \u0026lt; tableCount; i++) { String[] splitTable = table[i].split(\u0026#34; \u0026#34;); // 해당 점수별로 값 넣기 jobResultMap.put(splitTable[0], 0); for (int j = 1; j \u0026lt; splitTable.length; j++) { for (int k = 0; k \u0026lt; languages.length; k++) { if (splitTable[j].equals(languages[k])) { jobResultMap.put(splitTable[0], jobResultMap.get(splitTable[0]) + (splitTable.length - j) * preference[k]); } } } } List\u0026lt;String\u0026gt; listKeySet = new ArrayList\u0026lt;\u0026gt;(jobResultMap.keySet()); Collections.sort(listKeySet, (value1, value2) -\u0026gt; (jobResultMap.get(value2).compareTo(jobResultMap.get(value1)))); String answer = listKeySet.get(0); System.out.println(jobResultMap.toString()); System.out.println(listKeySet.toString()); return answer; } } ","permalink":"https://haservi.github.io/posts/algorithms/programmers/level1/02-algo-recommend-job/","summary":"직업군 추천하기 문제 설명 개발자가 사용하는 언어와 언어 선호도를 입력하면 그에 맞는 직업군을 추천해주는 알고리즘을 개발하려고 합니다.\n아래 표는 5개 직업군 별로 많이 사용하는 5개 언어에 직업군 언어 점수를 부여한 표입니다.\n점수 SI CONTENTS HARDWARE PORTAL GAME 5 JAVA JAVASCRIPT C JAVA C++ 4 JAVASCRIPT JAVA C++ JAVASCRIPT C# 3 SQL PYTHON PYTHON PYTHON JAVASCRIPT 2 PYTHON SQL JAVA KOTLIN C 1 C# C++ JAVASCRIPT PHP JAVA 예를 들면, SQL의 SI 직업군 언어 점수는 3점이지만 CONTENTS 직업군 언어 점수는 2점입니다.","title":"[프로그래머스]직업군 추천하기"},{"content":"비밀지도 문제 설명 네오는 평소 프로도가 비상금을 숨겨놓는 장소를 알려줄 비밀지도를 손에 넣었다.\n그런데 이 비밀지도는 숫자로 암호화되어 있어 위치를 확인하기 위해서는 암호를 해독해야 한다.\n다행히 지도 암호를 해독할 방법을 적어놓은 메모도 함께 발견했다.\n지도는 한 변의 길이가 n인 정사각형 배열 형태로, 각 칸은 \u0026ldquo;공백\u0026rdquo;(\u0026quot; \u0026ldquo;) 또는 \u0026ldquo;벽\u0026rdquo;(\u0026rdquo;#\u0026quot;) 두 종류로 이루어져 있다. 전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 각각 \u0026ldquo;지도 1\u0026quot;과 \u0026ldquo;지도 2\u0026quot;라고 하자.\n지도 1 또는 지도 2 중 어느 하나라도 벽인 부분은 전체 지도에서도 벽이다.\n지도 1과 지도 2에서 모두 공백인 부분은 전체 지도에서도 공백이다. \u0026ldquo;지도 1\u0026quot;과 \u0026ldquo;지도 2\u0026quot;는 각각 정수 배열로 암호화되어 있다. 암호화된 배열은 지도의 각 가로줄에서 벽 부분을 1, 공백 부분을 0으로 부호화했을 때 얻어지는 이진수에 해당하는 값의 배열이다. 네오가 프로도의 비상금을 손에 넣을 수 있도록, 비밀지도의 암호를 해독하는 작업을 도와줄 프로그램을 작성하라.\n입력 형식 입력으로 지도의 한 변 크기 n 과 2개의 정수 배열 arr1, arr2가 들어온다.\n1 ≦ n ≦ 16 arr1, arr2는 길이 n인 정수 배열로 주어진다. 정수 배열의 각 원소 x를 이진수로 변환했을 때의 길이는 n 이하이다. 즉, 0 ≦ x ≦ 2n - 1을 만족한다. 출력 형식 원래의 비밀지도를 해독하여 '#', 공백으로 구성된 문자열 배열로 출력하라.\n입출력 예제 매개변수 값 n 5 arr1 [9, 20, 28, 18, 11] arr2 [30, 1, 21, 17, 28] 출력 [\u0026rdquo;#####\u0026rdquo;,\u0026rdquo;# # #\u0026rdquo;, \u0026ldquo;### #\u0026rdquo;, \u0026ldquo;# ##\u0026rdquo;, \u0026ldquo;#####\u0026rdquo;] 매개변수 값 n 6 arr1 [46, 33, 33 ,22, 31, 50] arr2 [27 ,56, 19, 14, 14, 10] 출력 [\u0026quot;######\u0026quot;, \u0026ldquo;### #\u0026rdquo;, \u0026ldquo;## ##\u0026rdquo;, \u0026quot; #### \u0026ldquo;, \u0026quot; #####\u0026rdquo;, \u0026ldquo;### # \u0026ldquo;] 문제 풀이 리뷰 각각의 미로의 길을 이진화 한다. 만약 이진수의 값의 앞 공백이 있는 경우 \u0026ldquo;0\u0026quot;을 추가해준다. 서로 비교하여 0인 경우는 \u0026quot; \u0026ldquo;, 그렇지 않은 경우 \u0026ldquo;#\u0026ldquo;을 추가해준다. 해결 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 import java.util.*; class Solution { public static void main(String[] args) { Solution solution = new Solution(); int n = 5; int[] arr1 = { 9, 20, 28, 18, 11 }; int[] arr2 = { 30, 1, 21, 17, 28 }; String[] result = solution.solution(n, arr1, arr2); System.out.println(\u0026#34;결과 : \u0026#34; + Arrays.toString(result)); } public String[] solution(int n, int[] arr1, int[] arr2) { String[] answer = new String[n]; // 경로를 십진수를 이진수로 변경 및 이진수 앞 공백 추가 int count = n; for (int i = 0; i \u0026lt; count; i++) { String firstKeyMap = makeZero(Integer.toBinaryString(arr1[i]), count); String secondKeyMap = makeZero(Integer.toBinaryString(arr2[i]), count); String rowKey = \u0026#34;\u0026#34;; // System.out.println(firstKeyMap); for (int j = 0; j \u0026lt; count; j++) { if ((firstKeyMap.charAt(j) == \u0026#39;0\u0026#39;) \u0026amp;\u0026amp; (secondKeyMap.charAt(j) == \u0026#39;0\u0026#39;)) { rowKey += \u0026#34; \u0026#34;; } else { rowKey += \u0026#34;#\u0026#34;; } } // System.out.println(rowKey); answer[i] = rowKey; } return answer; } private String makeZero(String binaryString, int length) { int binaryLength = binaryString.length(); while (binaryLength != length) { binaryString = \u0026#34;0\u0026#34; + binaryString; binaryLength++; } return binaryString; } } ","permalink":"https://haservi.github.io/posts/algorithms/programmers/level1/01-algo-secret-map/","summary":"비밀지도 문제 설명 네오는 평소 프로도가 비상금을 숨겨놓는 장소를 알려줄 비밀지도를 손에 넣었다.\n그런데 이 비밀지도는 숫자로 암호화되어 있어 위치를 확인하기 위해서는 암호를 해독해야 한다.\n다행히 지도 암호를 해독할 방법을 적어놓은 메모도 함께 발견했다.\n지도는 한 변의 길이가 n인 정사각형 배열 형태로, 각 칸은 \u0026ldquo;공백\u0026rdquo;(\u0026quot; \u0026ldquo;) 또는 \u0026ldquo;벽\u0026rdquo;(\u0026rdquo;#\u0026quot;) 두 종류로 이루어져 있다. 전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 각각 \u0026ldquo;지도 1\u0026quot;과 \u0026ldquo;지도 2\u0026quot;라고 하자.\n지도 1 또는 지도 2 중 어느 하나라도 벽인 부분은 전체 지도에서도 벽이다.","title":"[프로그래머스]비밀지도"},{"content":"","permalink":"https://haservi.github.io/projects/","summary":"projects","title":"Projects"}]